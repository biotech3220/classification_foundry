{
  "name": "OBJECT-3_v3.8.1_Gen4 Workflow Google Drive (Classification, Assessment & Constraints)",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        16,
        1136
      ],
      "id": "cbd955af-e65a-4f1e-836c-f4575fd25ef6",
      "name": "When clicking ‚ÄòExecute workflow‚Äô"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        208,
        1968
      ],
      "id": "9f887e08-0016-4b33-8f7d-285100603be8",
      "name": "Fetch FATObjects",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Neo4j Response - Extract FATObjects with FULL dense_view\n// v3.8.5: FIXED - Handle array-wrapped Neo4j response [{data: {...}}]\nconst neo4jResponse = $input.first().json;\nconsole.log('üîß Running Parse Neo4j Response v3.8.5');\n\n// ============================================================\n// v3.8.5 FIX: Unwrap array if Neo4j returns [{data: {...}}]\n// ============================================================\nconst responseData = Array.isArray(neo4jResponse) ? neo4jResponse[0] : neo4jResponse;\nconsole.log('üì• Is array?', Array.isArray(neo4jResponse));\nconsole.log('üì• Has data.values?', !!responseData?.data?.values);\n\nif (!responseData.data?.values || responseData.data.values.length === 0) {\n  console.log('‚ùå FAILED - responseData:', JSON.stringify(responseData, null, 2).substring(0, 500));\n  throw new Error('No FATObjects returned from Neo4j');\n}\n\nconst results = [];\n\nfor (const row of responseData.data.values) {\n  // ============================================================\n  // v3.8.3: Column order matches new Cypher query\n  // ============================================================\n  const obj = {\n    asset_id: row[0],\n    name: row[1],           // from display_name\n    orcid: row[2],          // from orcid_id\n    institution: row[3],    // from org.display_name (via AFFILIATED_WITH)\n    dense_view: row[4],     // from dense_text\n    status: row[5],\n    version: row[6],\n    provenance: row[7],\n    fabricated_at: row[8]   // from updated_at\n  };\n\n  // v3.8.2: Parse provenance to get data_sources\n  let provenanceParsed = {};\n  let dataSources = [];\n  if (obj.provenance) {\n    try {\n      provenanceParsed = typeof obj.provenance === 'string'\n        ? JSON.parse(obj.provenance)\n        : obj.provenance;\n      dataSources = provenanceParsed.data_sources || [];\n    } catch (e) {\n      console.log(`‚ö†Ô∏è Failed to parse provenance for ${obj.name}`);\n    }\n  }\n\n  // dense_text is already formatted plain text - use directly as dense_view_text\n  const denseViewText = obj.dense_view || '';\n  \n  // Use institution from query (org.display_name) - fallback to parsing if null\n  let institution = obj.institution;\n  if (!institution || institution === 'Unknown') {\n    const institutionMatch = denseViewText.match(/Institution:\\s*([^\\n]+)/);\n    institution = institutionMatch ? institutionMatch[1].trim() : 'Unknown';\n  }\n  \n  // ============================================================\n  // v3.8.4: PARSE PUBLICATIONS INTO STRUCTURED ARRAY\n  // ============================================================\n  const publicationsSection = denseViewText.match(/PUBLICATIONS:\\s*([\\s\\S]*?)(?=\\n\\nGRANTS:|$)/);\n  const publications = [];\n  if (publicationsSection && publicationsSection[1]) {\n    const pubLines = publicationsSection[1].trim().split('\\n').filter(l => l.trim());\n    for (const line of pubLines) {\n      const pubMatch = line.match(/^\\d+\\.\\s*(.+?)(?:\\s*\\((\\d{4})\\))?$/);\n      if (pubMatch) {\n        publications.push({\n          title: pubMatch[1].trim(),\n          year: pubMatch[2] ? parseInt(pubMatch[2], 10) : null\n        });\n      }\n    }\n  }\n  \n  // ============================================================\n  // v3.8.4: PARSE GRANTS INTO STRUCTURED ARRAY\n  // ============================================================\n  const grantsSection = denseViewText.match(/GRANTS:\\s*([\\s\\S]*?)(?=\\nBIOGRAPHY:|$)/);\n  const grants = [];\n  if (grantsSection && grantsSection[1]) {\n    const grantText = grantsSection[1].trim();\n    if (grantText.length > 0) {\n      // Split by grant number pattern\n      const grantBlocks = grantText.split(/(?=\\d+\\.\\s+)/).filter(b => b.trim());\n      for (const block of grantBlocks) {\n        const lines = block.split('\\n');\n        const titleMatch = lines[0]?.match(/^\\d+\\.\\s*(.+)$/);\n        const title = titleMatch ? titleMatch[1].trim() : '';\n        const funderMatch = block.match(/Funder:\\s*([^,\\n]+)/);\n        const amountMatch = block.match(/Amount:\\s*\\$?([\\d,\\.]+)/);\n        if (title) {\n          grants.push({\n            title: title,\n            funder: funderMatch ? funderMatch[1].trim() : null,\n            amount: amountMatch ? amountMatch[1].replace(/,/g, '') : null\n          });\n        }\n      }\n    }\n  }\n  \n  // ============================================================\n  // EXTRACT OTHER FIELDS FROM DENSE_TEXT (plain text parsing)\n  // ============================================================\n  \n  // Extract biography\n  const biographyMatch = denseViewText.match(/BIOGRAPHY:\\s*([\\s\\S]*?)(?=\\n\\nRESEARCH INTERESTS:|\\n\\n===|$)/);\n  const biography = biographyMatch ? biographyMatch[1].trim() : '';\n  \n  // Extract career stage\n  const careerMatch = denseViewText.match(/Career Stage:\\s*([^\\n]+)/);\n  const careerStage = careerMatch ? careerMatch[1].trim() : 'unknown';\n  \n  // Extract research domains\n  const domainsMatch = denseViewText.match(/Research Domains:\\s*([^\\n]+)/);\n  const researchDomains = domainsMatch \n    ? domainsMatch[1].split(',').map(d => d.trim()).filter(d => d)\n    : [];\n  \n  // Extract methodologies\n  const methodsMatch = denseViewText.match(/Methodologies:\\s*([^\\n]+)/);\n  const methodologies = methodsMatch\n    ? methodsMatch[1].split(',').map(m => m.trim()).filter(m => m)\n    : [];\n  \n  // Extract research themes\n  const themesMatch = denseViewText.match(/Research Themes:\\s*([^\\n]+)/);\n  const researchThemes = themesMatch\n    ? themesMatch[1].split(',').map(t => t.trim()).filter(t => t)\n    : [];\n  \n  // Extract keywords\n  const keywordsMatch = denseViewText.match(/Keywords:\\s*([^\\n]+)/);\n  const keywords = keywordsMatch\n    ? keywordsMatch[1].split(',').map(k => k.trim()).filter(k => k)\n    : [];\n  \n  // Extract research interests\n  const interestsMatch = denseViewText.match(/RESEARCH INTERESTS:\\s*([\\s\\S]*?)(?=\\n\\n===|$)/);\n  const researchInterests = interestsMatch\n    ? interestsMatch[1].split(',').map(i => i.trim()).filter(i => i)\n    : [];\n  \n  // Extract metrics\n  const hIndexMatch = denseViewText.match(/H-index:\\s*(\\d+)/);\n  const hIndex = hIndexMatch ? parseInt(hIndexMatch[1], 10) : 0;\n  \n  const citationsMatch = denseViewText.match(/Citations:\\s*(\\d+)/);\n  const totalCitations = citationsMatch ? parseInt(citationsMatch[1], 10) : 0;\n  \n  const pubCountMatch = denseViewText.match(/Publications:\\s*(\\d+)/);\n  const publicationCount = pubCountMatch ? parseInt(pubCountMatch[1], 10) : 0;\n  \n  const patentCountMatch = denseViewText.match(/Patents:\\s*(\\d+)/);\n  const patentCount = patentCountMatch ? parseInt(patentCountMatch[1], 10) : 0;\n\n  // ============================================================\n  // v3.8.4: BUILD raw_evidence AND enriched_context OBJECTS\n  // These are what the LLM Prompt node expects!\n  // ============================================================\n  const rawEvidence = {\n    publications: publications,\n    grants: grants,\n    biography: biography,\n    research_interests: researchInterests\n  };\n  \n  const enrichedContext = {\n    career_stage: careerStage,\n    research_domains: researchDomains,\n    methodologies: methodologies,\n    themes: researchThemes,\n    keywords: keywords\n  };\n\n  // Build Qdrant scroll request\n  const qdrantScrollRequest = {\n    filter: {\n      must: [{ key: \"asset_id\", match: { value: obj.asset_id } }]\n    },\n    limit: 1,\n    with_payload: true,\n    with_vector: true\n  };\n\n  results.push({\n    json: {\n      asset_id: obj.asset_id,\n      name: obj.name,\n      orcid: obj.orcid,\n      institution: institution,\n      status: obj.status,\n      version: obj.version,\n      fabricated_at: obj.fabricated_at || provenanceParsed.enrichment_timestamp || null,\n      \n      // v3.8.4: Structured objects for LLM Prompt\n      raw_evidence: rawEvidence,\n      enriched_context: enrichedContext,\n      dense_view_parsed: {\n        raw_evidence: rawEvidence,\n        enriched_context: enrichedContext\n      },\n      dense_view_text: denseViewText,\n      \n      // Flat fields for backward compatibility\n      biography: biography,\n      research_domains: researchDomains,\n      methodologies: methodologies,\n      research_themes: researchThemes,\n      research_interests: researchInterests,\n      career_stage: careerStage,\n      h_index: hIndex,\n      total_citations: totalCitations,\n      publication_count: publicationCount,\n      patent_count: patentCount,\n      \n      // v3.8.2: Data sources from provenance\n      data_sources: dataSources,\n      provenance: provenanceParsed,\n      \n      qdrant_scroll_request: qdrantScrollRequest\n    }\n  });\n}\n\nconsole.log(`‚úÖ Parsed ${results.length} FATObjects with comprehensive profiles`);\nconsole.log(`   Name: ${results[0]?.json?.name}`);\nconsole.log(`   Institution: ${results[0]?.json?.institution}`);\nconsole.log(`   Publications: ${results[0]?.json?.raw_evidence?.publications?.length || 0}`);\nconsole.log(`   Grants: ${results[0]?.json?.raw_evidence?.grants?.length || 0}`);\nconsole.log(`   Biography: ${results[0]?.json?.raw_evidence?.biography?.length || 0} chars`);\nconsole.log(`   H-index: ${results[0]?.json?.h_index}`);\nconsole.log(`   Career Stage: ${results[0]?.json?.career_stage}`);\nconsole.log(`   üìä Data sources: ${results[0]?.json?.data_sources?.join(', ') || 'none'}`);\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        1968
      ],
      "id": "fc0f8fc1-2337-4a7f-87c5-630f3e2253ab",
      "name": "Parse Neo4j Response"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/objects_researcher_v1/points/scroll",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"filter\": { \"must\": [ { \"key\": \"asset_id\", \"match\": { \"value\": $json.asset_id } } ] }, \"limit\": 1, \"with_payload\": true, \"with_vector\": true } }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "615673cf-74f1-4597-a866-98099d7e16e1",
      "name": "Fetch Embedding Vector",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        2256,
        1968
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Node: Merge Embedding\n// Version: v3.7.0\n// Purpose: Merge Qdrant embedding vector with researcher data from earlier nodes\n// ============================================================\n\nconst qdrantResponse = $input.first().json;\n\n// ============================================================\n// GET DATA FROM PREVIOUS NODE (Handle Sparse Data or Parse Neo4j Response)\n// This contains dense_view_text, raw_evidence, etc.\n// ============================================================\nlet previousData = {};\n\n// Try to get from Handle Sparse Data first\ntry {\n  previousData = $('Handle Sparse Data').item.json;\n} catch (e) {\n  // Fallback to Parse Neo4j Response\n  try {\n    previousData = $('Parse Neo4j Response').item.json;\n  } catch (e2) {\n    console.log('‚ö†Ô∏è Could not find previous node data');\n  }\n}\n\n// ============================================================\n// PARSE QDRANT RESPONSE\n// ============================================================\nconst responseData = Array.isArray(qdrantResponse) ? qdrantResponse[0] : qdrantResponse;\nconst points = responseData.result?.points || [];\n\nif (points.length === 0) {\n  throw new Error('No points found in Qdrant response');\n}\n\nconst point = points[0];\nconst embeddingVector = point.vector;\nconst payload = point.payload;\n\nif (!embeddingVector || !Array.isArray(embeddingVector)) {\n  throw new Error('Vector not returned or invalid format');\n}\n\nif (!payload || !payload.asset_id) {\n  throw new Error('Payload missing or invalid');\n}\n\n// ============================================================\n// MERGE: Combine Qdrant data with previous node data\n// Priority: previousData > payload (for text fields)\n// ============================================================\nconst mergedData = {\n  // Core identifiers\n  asset_id: payload.asset_id,\n  qdrant_point_id: point.id,\n  \n  // Researcher info (prefer previous node data)\n  name: previousData.name || payload.name,\n  orcid: previousData.orcid || payload.orcid,\n  institution: previousData.institution || payload.institution,\n  \n  // ============================================================\n  // CRITICAL: dense_view_text from previous node (NOT Qdrant)\n  // ============================================================\n  dense_view_text: previousData.dense_view_text || '',\n  dense_view_parsed: previousData.dense_view_parsed || {},\n  \n  // ============================================================\n  // v3.7: raw_evidence and enriched_context from previous node\n  // ============================================================\n  raw_evidence: previousData.raw_evidence || {},\n  enriched_context: previousData.enriched_context || {},\n  \n  // Research profile (merge both sources)\n  career_stage: previousData.career_stage || payload.career_stage || 'unknown',\n  research_domains: previousData.research_domains || payload.research_domains || [],\n  methodologies: previousData.methodologies || payload.methodologies || [],\n  research_themes: previousData.research_themes || payload.research_themes || [],\n  \n  // Metrics (prefer Qdrant payload as it may be more accurate)\n  h_index: payload.h_index || previousData.h_index || 0,\n  total_citations: payload.total_citations || previousData.total_citations || 0,\n  publication_count: payload.publication_count || previousData.publication_count || 0,\n  patent_count: payload.patent_count || previousData.patent_count || 0,\n  research_impact: payload.research_impact || previousData.research_impact || 'Unknown',\n  \n  // The embedding vector (3072 dimensions)\n  embedding_vector: embeddingVector,\n  embedding_dimensions: embeddingVector.length,\n  \n  // Data quality from previous node\n  data_quality: previousData.data_quality || {},\n  data_completeness: payload.data_completeness || previousData.data_completeness || 0,\n  \n  // Status\n  status: payload.status || previousData.status,\n  fabricated_at: payload.fabricated_at || previousData.fabricated_at\n};\n\n// ============================================================\n// VALIDATION: Ensure dense_view_text is not empty\n// ============================================================\nif (!mergedData.dense_view_text || mergedData.dense_view_text.trim().length === 0) {\n  console.log('‚ö†Ô∏è WARNING: dense_view_text is empty!');\n  console.log('   previousData keys:', Object.keys(previousData));\n  console.log('   payload keys:', Object.keys(payload));\n  \n  // Build fallback dense_view_text from available data\n  const fallbackText = `\nResearcher: ${mergedData.name}\nInstitution: ${mergedData.institution}\nCareer Stage: ${mergedData.career_stage}\nResearch Domains: ${mergedData.research_domains.join(', ')}\nMethodologies: ${mergedData.methodologies.join(', ')}\nResearch Themes: ${mergedData.research_themes.join(', ')}\nH-index: ${mergedData.h_index}\n  `.trim();\n  \n  mergedData.dense_view_text = fallbackText;\n  console.log('   Created fallback dense_view_text');\n}\n\nconsole.log(`‚úÖ Merge Embedding: ${mergedData.name}`);\nconsole.log(`   Embedding dimensions: ${mergedData.embedding_dimensions}`);\nconsole.log(`   dense_view_text length: ${mergedData.dense_view_text.length} chars`);\nconsole.log(`   raw_evidence.publications: ${(mergedData.raw_evidence.publications || []).length}`);\n\nreturn [{\n  json: mergedData\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        1968
      ],
      "id": "6ab065af-98ef-440e-bd63-cf56fac7fa16",
      "name": "Merge Embedding"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.user_prompt }}",
        "messages": {
          "messageValues": [
            {
              "message": "Assign 3-10 codes that comprehensively represent the researcher's expertise. Adjust count based on career complexity: - Early-career/narrow focus: 3-5 codes - Mid-career/multi-domain: 5-7 codes   - Senior/interdisciplinary: 7-10 codes Only assign codes where you have high confidence (0.70+)"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2624,
        2256
      ],
      "id": "9515c0e0-e0a9-4152-b12c-025d31aa51fc",
      "name": "Pass 2: LLM Enrichment"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Node: Parse LLM Response (with Retry Support)\n// Version: v3.8.3 - FIXED: Capture evidence array for OECD FOS\n// Extracts BOTH Standard A (ANZSRC) and Standard B (OECD FOS) classifications\n// Added: Error handling with retry flag\n// ============================================================\n\nconst llmResponse = $input.first().json;\nconst promptData = $('Prepare Dual-Standard LLM Prompt').item.json;\n\n// Track retry attempts\nconst currentRetryCount = promptData.llm_retry_count || 0;\nconst MAX_RETRIES = 2;\n\n// Extract content from LLM response\nlet content;\n\ntry {\n  if (llmResponse.choices?.[0]?.message?.content) {\n    content = llmResponse.choices[0].message.content;\n  } else if (llmResponse.text) {\n    content = llmResponse.text;\n  } else if (llmResponse.output) {\n    content = llmResponse.output;\n  } else if (Array.isArray(llmResponse) && llmResponse[0]?.text) {\n    content = llmResponse[0].text;\n  } else {\n    throw new Error(`Unexpected LLM response structure: ${JSON.stringify(llmResponse).slice(0, 200)}`);\n  }\n\n  if (!content) {\n    throw new Error('No content in LLM response');\n  }\n\n  // Parse JSON from response\n  let parsed;\n  let cleanContent = content.trim();\n  \n  // Remove markdown code blocks if present\n  if (cleanContent.startsWith('```json')) {\n    cleanContent = cleanContent.slice(7);\n  } else if (cleanContent.startsWith('```')) {\n    cleanContent = cleanContent.slice(3);\n  }\n  if (cleanContent.endsWith('```')) {\n    cleanContent = cleanContent.slice(0, -3);\n  }\n  \n  parsed = JSON.parse(cleanContent.trim());\n\n  // Validate structure\n  if (!parsed.standard_a?.classifications) {\n    throw new Error('LLM response missing standard_a.classifications');\n  }\n\n  const CONFIDENCE_THRESHOLD = 0.70;\n\n  // Process Standard A (ANZSRC)\n  const standardAClassifications = (parsed.standard_a.classifications || [])\n    .filter(c => c.confidence >= CONFIDENCE_THRESHOLD)\n    .map(c => ({\n      code: String(c.code),\n      name: c.name || 'Unknown',\n      confidence: Math.min(1.0, Math.max(0.0, c.confidence)),\n      justification: c.justification || '',\n      evidence: c.evidence || []\n    }))\n    .sort((a, b) => b.confidence - a.confidence);\n\n  // ============================================================\n  // v3.8.3 FIX: Process Standard B (OECD FOS) WITH EVIDENCE\n  // Now captures evidence array if provided by LLM\n  // ============================================================\n  const standardBClassifications = (parsed.standard_b?.classifications || [])\n    .filter(c => c.confidence >= CONFIDENCE_THRESHOLD)\n    .map(c => ({\n      code: String(c.code),\n      name: c.name || 'Unknown',\n      confidence: Math.min(1.0, Math.max(0.0, c.confidence)),\n      justification: c.justification || '',\n      evidence: c.evidence || []  // v3.8.3: Added evidence capture\n    }))\n    .sort((a, b) => b.confidence - a.confidence);\n\n  console.log(`‚úÖ Standard A: ${standardAClassifications.length} codes`);\n  console.log(`‚úÖ Standard B: ${standardBClassifications.length} codes`);\n  // v3.8.3: Log evidence capture stats\n  const fosWithEvidence = standardBClassifications.filter(c => c.evidence.length > 0).length;\n  console.log(`   üìã FOS codes with evidence: ${fosWithEvidence}/${standardBClassifications.length}`);\n\n  return [{\n    json: {\n      // Core identifiers\n      asset_id: promptData.asset_id,\n      name: promptData.name,\n      orcid: promptData.orcid,\n      institution: promptData.institution,\n      qdrant_point_id: promptData.qdrant_point_id,\n      \n      // Parse success\n      parse_success: true,\n      needs_retry: false,\n      \n      // Standard A classifications\n      classifications: standardAClassifications,\n      classification_count: standardAClassifications.length,\n      \n      // Standard B classifications (v3.8.3: now with evidence)\n      standard_b_classifications: standardBClassifications,\n      standard_b_count: standardBClassifications.length,\n      \n      // Reasoning\n      reasoning: parsed.reasoning || '',\n      \n      // LLM metadata\n      model: llmResponse.model || 'anthropic/claude-opus-4.5',\n      llm_retry_count: currentRetryCount\n    }\n  }];\n\n} catch (parseError) {\n  // JSON parsing failed - check if we can retry\n  console.log(`‚ö†Ô∏è LLM Parse Error for ${promptData.name}: ${parseError.message}`);\n  console.log(`   Retry count: ${currentRetryCount}/${MAX_RETRIES}`);\n  \n  if (currentRetryCount < MAX_RETRIES) {\n    // Flag for retry\n    return [{\n      json: {\n        // Pass through all original data for retry\n        ...promptData,\n        \n        // Retry flags\n        parse_success: false,\n        needs_retry: true,\n        llm_retry_count: currentRetryCount + 1,\n        \n        // Error details\n        parse_error: parseError.message,\n        failed_content_preview: content ? content.slice(0, 500) : 'No content',\n        \n        // Will be used by retry logic\n        retry_reason: 'JSON parse failure - truncated or malformed response'\n      }\n    }];\n  } else {\n    // Max retries exceeded - route to failed\n    return [{\n      json: {\n        asset_id: promptData.asset_id,\n        name: promptData.name,\n        orcid: promptData.orcid,\n        institution: promptData.institution,\n        qdrant_point_id: promptData.qdrant_point_id,\n        \n        // Failure flags\n        parse_success: false,\n        needs_retry: false,\n        classification_failed: true,\n        \n        // Error details\n        parse_error: parseError.message,\n        failed_content_preview: content ? content.slice(0, 500) : 'No content',\n        llm_retry_count: currentRetryCount,\n        failure_reason: `Max retries (${MAX_RETRIES}) exceeded - JSON parse failure`\n      }\n    }];\n  }\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        2576
      ],
      "id": "22f673c3-4892-431e-b477-c9414c136a90",
      "name": "Parse LLM Response"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Neo4j Write Query - Dual Standard + CRE Assessment\n// Gen 4 + v3.9: Fixed to write assessment_flags and metadata per Schema v1.5\n// Per Definition Card v3.9 and FATResearcher Schema v1.5\n// v3.9.1: Fixed nested object issues for Neo4j compatibility\n\nconst inputData = $input.first().json;\n\n// Handle classification failure\nif (inputData.classification_failed) {\n  const failedCypherPayload = {\n    statement: `\n      MATCH (obj:FATObject {asset_id: $asset_id})\n      SET obj.status = 'classification_failed',\n          obj.classification_failed_at = datetime(),\n          obj.classification_failed_reason = $failure_reason\n      RETURN obj.asset_id AS asset_id, obj.status AS status\n    `,\n    parameters: {\n      asset_id: inputData.asset_id,\n      failure_reason: inputData.failure_reason\n    }\n  };\n  \n  return [{\n    json: {\n      ...inputData,\n      neo4j_payload: failedCypherPayload,\n      is_failure_update: true\n    }\n  }];\n}\n\n// ============================================================\n// v3.9: Deduplicate Standard A classifications WITH TIER\n// Now includes rank and tier from upstream Calculate Final Confidence\n// ============================================================\nconst seenCodesA = new Set();\nconst uniqueClassificationsA = [];\n\nfor (const c of inputData.classifications) {\n  const codeStr = String(c.code);\n  if (!seenCodesA.has(codeStr)) {\n    seenCodesA.add(codeStr);\n    uniqueClassificationsA.push({\n      code: parseInt(c.code, 10),\n      name: c.name,\n      confidence: c.adjusted_confidence,\n      justification: c.justification,\n      evidence: c.evidence || [],\n      cf1_validated: c.cf1_validated || false,\n      // v3.8: Added tier fields\n      rank: c.rank || null,\n      tier: c.tier || null\n    });\n  }\n}\n\n// Prepare Standard B classifications\nconst standardBClassifications = (inputData.standard_b_classifications || []).map(c => ({\n  code: String(c.code),\n  name: c.name,\n  confidence: c.confidence,\n  justification: c.justification || ''\n}));\n\n// ============================================================\n// v3.9: Build assessment_flags per Schema v1.5 Section 3.2\n// ============================================================\nconst existingCre = $('Merge CRE Output').item.json.cre_assessment || {};\nconst cf1Assessment = inputData.cf1_assessment || {};\nconst crosswalk = inputData.crosswalk_assessment || {};\n\nconst cf1Result = existingCre.cf1_result || {};\nconst cf5Result = existingCre.cf5_result || {};\n\n// Build assessment_flags structure (NOT creAssessment)\nconst assessmentFlags = {\n  crosswalk_alignment: crosswalk.alignment_score || null,\n  constraint_results: {\n    cf1_trl: {\n      passed: cf1Result.passed !== false,\n      gate_mode: cf1Result.gate_mode || 'block',\n      inferred_level: cf1Result.inferred_level || null,\n      required_level: cf1Result.required_level || null,\n      confidence: cf1Result.confidence || null,\n      evidence: cf1Result.evidence || [],\n      message: cf1Result.message || ''\n    },\n    cf5_regulatory: {\n      passed: cf5Result.passed !== false,\n      gate_mode: cf5Result.gate_mode || 'block',\n      warnings: cf5Result.warnings || [],\n      checked_domains: cf5Result.checked_domains || [],\n      message: cf5Result.message || ''\n    },\n    anzsrc_hierarchy: {\n      passed: cf1Assessment.passed !== false,\n      violations: cf1Assessment.violations || [],\n      flags: cf1Assessment.flags || [],\n      penalty: cf1Assessment.penalty || 0\n    }\n  },\n  blocking_failures: existingCre.blocking_failures || [],\n  penalising_failures: existingCre.penalising_failures || [],\n  requires_hitl: existingCre.requires_hitl || false,\n  warnings: []\n};\n\n// ============================================================\n// v3.9.1: Build Cypher query WITH PROPER SCHEMA v1.5 PROPERTIES\n// - assessment_flags: JSON stringified (Neo4j can't store nested objects)\n// - classified_by and classification_timestamp: flat properties (not nested metadata)\n// ============================================================\nconst cypherPayload = {\n  statement: `\n    MATCH (obj:FATObject {asset_id: $asset_id})\n    SET obj.status = 'classified',\n        obj.final_confidence = $final_confidence,\n        obj.assessment_flags = $assessment_flags,\n        obj.classified_by = $agent_id,\n        obj.classification_timestamp = datetime()\n    \n    WITH obj\n    \n    UNWIND $classifications_a AS cls\n    MATCH (std_a:Standard:FoR {code: cls.code})\n    MERGE (obj)-[r_a:CLASSIFIED_AS]->(std_a)\n    ON CREATE SET \n      r_a.confidence = cls.confidence,\n      r_a.justification = cls.justification,\n      r_a.evidence = cls.evidence,\n      r_a.classified_at = datetime(),\n      r_a.classified_by = $agent_id,\n      r_a.model = $model,\n      r_a.standard_type = 'primary',\n      r_a.taxonomy = 'ANZSRC_FoR_2020',\n      r_a.validated = false,\n      r_a.validation_state = 'PENDING',\n      r_a.cf1_validated = cls.cf1_validated,\n      r_a.rank = cls.rank,\n      r_a.tier = cls.tier\n    ON MATCH SET\n      r_a.confidence = cls.confidence,\n      r_a.justification = cls.justification,\n      r_a.evidence = cls.evidence,\n      r_a.classified_at = datetime(),\n      r_a.classified_by = $agent_id,\n      r_a.model = $model,\n      r_a.rank = cls.rank,\n      r_a.tier = cls.tier\n    \n    WITH obj, count(r_a) AS anzsrc_count\n    \n    UNWIND $classifications_b AS cls_b\n    MATCH (std_b:Standard:OECD_FOS {code: cls_b.code})\n    MERGE (obj)-[r_b:CLASSIFIED_AS]->(std_b)\n    ON CREATE SET \n      r_b.confidence = cls_b.confidence,\n      r_b.justification = cls_b.justification,\n      r_b.classified_at = datetime(),\n      r_b.classified_by = $agent_id,\n      r_b.model = $model,\n      r_b.standard_type = 'domain_hub',\n      r_b.taxonomy = 'OECD_FOS_2007',\n      r_b.validated = false,\n      r_b.validation_state = 'PENDING'\n    ON MATCH SET\n      r_b.confidence = cls_b.confidence,\n      r_b.justification = cls_b.justification,\n      r_b.classified_at = datetime(),\n      r_b.classified_by = $agent_id,\n      r_b.model = $model\n    \n    RETURN obj.asset_id AS asset_id, \n           obj.status AS status,\n           anzsrc_count AS standard_a_relationships,\n           count(r_b) AS standard_b_relationships\n  `,\n  parameters: {\n    asset_id: inputData.asset_id,\n    agent_id: 'object3_classifier_v3.9.0',\n    model: inputData.model || 'openai/gpt-5.2-pro',\n    final_confidence: inputData.final_confidence,\n    classifications_a: uniqueClassificationsA,\n    classifications_b: standardBClassifications,\n    assessment_flags: JSON.stringify(assessmentFlags)\n  }\n};\n\n// ============================================================\n// v3.9: Enhanced logging with tier info\n// ============================================================\nconst primaryCount = uniqueClassificationsA.filter(c => c.tier === 'primary').length;\nconst secondaryCount = uniqueClassificationsA.filter(c => c.tier === 'secondary').length;\n\nconsole.log(`‚úÖ Neo4j write: ${uniqueClassificationsA.length} ANZSRC + ${standardBClassifications.length} FOS`);\nconsole.log(`   üìä Tiers: ${primaryCount} primary + ${secondaryCount} secondary`);\nconsole.log(`   üî¨ CRE: TRL=${assessmentFlags.constraint_results.cf1_trl.inferred_level}, conf=${assessmentFlags.constraint_results.cf1_trl.confidence}`);\n\nreturn [{\n  json: {\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    qdrant_point_id: inputData.qdrant_point_id,\n    classifications: uniqueClassificationsA,\n    classification_count: uniqueClassificationsA.length,\n    // v3.9: Pass through tier summary\n    tier_summary: inputData.tier_summary || {\n      primary_count: primaryCount,\n      secondary_count: secondaryCount\n    },\n    standard_b_classifications: standardBClassifications,\n    standard_b_count: standardBClassifications.length,\n    final_confidence: inputData.final_confidence,\n    cf1_assessment: inputData.cf1_assessment,\n    crosswalk_assessment: inputData.crosswalk_assessment,\n    assessment_flags: assessmentFlags,  // v3.9: Renamed from cre_assessment\n    confidence_breakdown: inputData.confidence_breakdown,\n    reasoning: inputData.reasoning,\n    classified_at: inputData.classified_at,\n    neo4j_payload: cypherPayload,\n    is_failure_update: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2176,
        2592
      ],
      "id": "e1adb3ec-b5d0-4ac3-b750-2877a772f32e",
      "name": "Prepare Neo4j Write Query"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        112,
        2864
      ],
      "id": "530f38ce-c66f-45f3-a346-6534f9a23adb",
      "name": "Write to Neo4j",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/objects_researcher_v1/points/payload",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $('Prepare Qdrant Payload').item.json.qdrant_payload }}",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        640,
        2864
      ],
      "id": "5ec3d8d7-ab77-4fc3-897f-c7f86b91ace1",
      "name": "Update Qdrant",
      "credentials": {
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Final Output - Dual Standard Summary + Signal Confirmation\n// Gen 4 + v3.8.3: FIXED - Pass through flag/violation details for PDF rendering\n// Version: v3.8.3 - Added flags_detail, violations_detail, and OECD evidence\n\n// ============================================================\n// GET DATA FROM UPSTREAM NODES\n// ============================================================\nconst inputData = $('Prepare Qdrant Payload').item.json;\nconst neo4jResult = $('Write to Neo4j').item.json;\nconst qdrantResult = $('Update Qdrant').item.json;\nconst postgresResult = $('Store Crosswalk Metadata').item.json;\n\n// FIXED: Get signal data from Prepare Classification Signals node (not HTTP response)\nconst signalData = $('Prepare Classification Signals').item.json;\nconst signalsEmitted = signalData.signals_emitted || [];\nconst signalCount = signalData.signal_count || 0;\n\n// Direct reference to CRE assessment from source node\nconst creAssessment = $('Merge CRE Output').item.json.cre_assessment || null;\n\n// v3.8.2: Get data_sources from Parse Neo4j Response (extracted from provenance)\nconst dataSources = $('Parse Neo4j Response').item.json.data_sources || [];\n\n// Parse Neo4j response for relationship counts\nconst neo4jValues = neo4jResult?.data?.values?.[0] || [];\nconst standardARelationships = neo4jValues[2] || 0;\nconst standardBRelationships = neo4jValues[3] || 0;\n\n// Get crosswalk status\nconst crosswalkStatus = inputData.crosswalk_assessment?.alignment_status \n  || (inputData.crosswalk_assessment?.alignment_score === null \n      ? \"no_crosswalks\" \n      : inputData.crosswalk_assessment?.alignment_score >= 0.50 \n        ? \"aligned\" \n        : inputData.crosswalk_assessment?.alignment_score >= 0.30\n          ? \"acceptable\"\n          : \"misaligned\");\n\n// ============================================================\n// v3.8: EXTRACT TIER INFORMATION\n// ============================================================\nconst classifications = inputData.classifications || [];\nconst primaryCodes = classifications.filter(c => c.tier === 'primary');\nconst secondaryCodes = classifications.filter(c => c.tier === 'secondary');\n\nconst tierSummary = inputData.tier_summary || {\n  primary_count: primaryCodes.length,\n  secondary_count: secondaryCodes.length,\n  untiered_count: classifications.filter(c => !c.tier).length\n};\n\nconst output = {\n  // === Classification Result ===\n  asset_id: inputData.asset_id,\n  name: inputData.name,\n  status: \"classified\",\n  \n  // === v3.8.2: DATA SOURCES (from provenance) ===\n  data_sources: {\n    scraped_from: dataSources,\n    count: dataSources.length,\n    description: \"Sources used to build researcher profile\"\n  },\n  \n  // === Standard A Classifications (ANZSRC) + v3.8 TIER ===\n  standard_a: {\n    taxonomy: \"ANZSRC_FoR_2020\",\n    role: \"primary_classification\",\n    classifications: inputData.classifications.map(c => ({\n      code: c.code,\n      name: c.name,\n      confidence: c.adjusted_confidence || c.confidence,\n      justification: c.justification,\n      evidence: c.evidence || [],\n      rank: c.rank || null,\n      tier: c.tier || null\n    })),\n    count: inputData.classification_count,\n    tiers: inputData.classifications.map(c => c.tier || 'untiered'),\n    tier_summary: tierSummary\n  },\n  \n  // === Standard B Classifications (OECD FOS) ===\n  // v3.8.3 FIX: Now includes evidence array\n  standard_b: {\n    taxonomy: \"OECD_FOS_2007\",\n    role: \"domain_hub\",\n    classifications: (inputData.standard_b_classifications || []).map(c => ({\n      code: c.code,\n      name: c.name,\n      confidence: c.confidence,\n      justification: c.justification,\n      evidence: c.evidence || []  // v3.8.3: Added evidence pass-through\n    })),\n    count: inputData.standard_b_count || 0\n  },\n  \n  // === Confidence & Assessment ===\n  assessment: {\n    final_confidence: inputData.final_confidence,\n    confidence_breakdown: inputData.confidence_breakdown,\n    \n    // v3.8.3 FIX: Pass through FULL flag and violation details for PDF rendering\n    anzsrc_hierarchy: {\n      passed: inputData.cf1_assessment?.passed || false,\n      violations: inputData.cf1_assessment?.violations?.length || 0,\n      violations_detail: inputData.cf1_assessment?.violations || [],  // v3.8.3: NEW\n      flags: inputData.cf1_assessment?.flags?.length || 0,\n      flags_detail: inputData.cf1_assessment?.flags || [],  // v3.8.3: NEW\n      penalty: inputData.cf1_assessment?.penalty || 0\n    },\n    \n    crosswalk: {\n      alignment_score: inputData.crosswalk_assessment?.alignment_score || null,\n      modifier: inputData.crosswalk_assessment?.modifier || 0,\n      mappings_checked: inputData.crosswalk_assessment?.total_mappings_checked || 0,\n      status: crosswalkStatus\n    },\n    \n    // v3.8.3 FIX: Map CRE data from BOTH possible structures\n    // Merge CRE Output uses constraint_results.CF1/CF5, but some paths use cf1_result/cf5_result\n    cre: creAssessment ? {\n      skipped: creAssessment.skipped || false,\n      cf1_trl: creAssessment.constraint_results?.CF1 || creAssessment.cf1_result || null,\n      cf5_regulatory: creAssessment.constraint_results?.CF5 || creAssessment.cf5_result || null,\n      blocking_failures: creAssessment.blocking_failures || [],\n      penalising_failures: creAssessment.penalising_failures || [],\n      cre_penalty: creAssessment.cre_penalty || 0,\n      requires_hitl: creAssessment.requires_hitl || false\n    } : null\n  },\n  \n  // === Reasoning ===\n  reasoning: inputData.reasoning,\n  \n  // === OBJECT-4 Routing Preview ===\n  routing: {\n    recommendation: inputData.final_confidence >= 0.85 \n      ? \"AUTO_APPROVE\" \n      : inputData.final_confidence >= 0.60 \n        ? \"HUMAN_REVIEW\" \n        : \"REJECT\",\n    confidence_threshold: inputData.final_confidence >= 0.85 \n      ? \">=0.85\" \n      : inputData.final_confidence >= 0.60 \n        ? \"0.60-0.85\" \n        : \"<0.60\",\n    requires_validation: inputData.final_confidence < 0.85,\n    blocked_by_cre: creAssessment?.blocking_failures?.length > 0 || false\n  },\n  \n  // === Storage Confirmation ===\n  storage: {\n    neo4j: {\n      status: \"success\",\n      standard_a_relationships: standardARelationships,\n      standard_b_relationships: standardBRelationships,\n      total_relationships: standardARelationships + standardBRelationships\n    },\n    qdrant: {\n      status: qdrantResult?.status || \"ok\",\n      point_id: inputData.qdrant_point_id\n    },\n    postgresql: {\n      status: postgresResult?.id ? \"success\" : \"ok\",\n      job_id: postgresResult?.job_id || null,\n      record_id: postgresResult?.id || null\n    }\n  },\n  \n  // === v3.7.2: SIGNALS EMITTED ===\n  signals: {\n    count: signalCount,\n    types: signalsEmitted.map(s => s.signal_type),\n    written_to_neo4j: true,\n    details: signalsEmitted.map(s => ({\n      type: s.signal_type,\n      category: s.category,\n      value: s.value\n    }))\n  },\n  \n  // === Metadata ===\n  metadata: {\n    classified_at: inputData.classified_at,\n    classified_by: \"object3_classifier_v3.8.3\",\n    model: inputData.model || \"anthropic/claude-opus-4.5\",\n    workflow_version: \"OBJECT-3_v3.8.3_Gen4_Sources\"\n  }\n};\n\n// ============================================================\n// LOG SUMMARY (v3.8.3: Enhanced with flag details)\n// ============================================================\nconsole.log(`\\n============================================================`);\nconsole.log(`‚úÖ CLASSIFICATION COMPLETE: ${output.name}`);\nconsole.log(`============================================================`);\nconsole.log(`   üìä Data Sources: ${dataSources.join(', ') || 'none'}`);\nconsole.log(`   Standard A: ${output.standard_a.count} codes (ANZSRC FoR 2020)`);\nconsole.log(`   üìä Tiers: ${tierSummary.primary_count} primary + ${tierSummary.secondary_count} secondary`);\nconsole.log(`   Standard B: ${output.standard_b.count} codes (OECD FOS 2007)`);\nconsole.log(`   Final Confidence: ${output.assessment.final_confidence}`);\nconsole.log(`   Routing: ${output.routing.recommendation}`);\nconsole.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);\nconsole.log(`   CF1 ANZSRC: ${output.assessment.anzsrc_hierarchy.passed ? 'PASSED' : 'FAILED'}`);\nconsole.log(`     Violations: ${output.assessment.anzsrc_hierarchy.violations}`);\nconsole.log(`     Flags: ${output.assessment.anzsrc_hierarchy.flags}`);\nif (output.assessment.anzsrc_hierarchy.flags_detail.length > 0) {\n  output.assessment.anzsrc_hierarchy.flags_detail.forEach(f => {\n    console.log(`       ‚Üí ${f.rule || 'flag'}: ${f.message || f.code || 'no details'}`);\n  });\n}\nconsole.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);\nconsole.log(`   CRE CF1 (TRL): ${creAssessment?.cf1_result?.passed ? 'PASSED' : 'N/A'} (Level ${creAssessment?.cf1_result?.inferred_level || 'N/A'})`);\nconsole.log(`   CRE CF5 (Regulatory): ${creAssessment?.cf5_result?.passed ? 'PASSED' : 'N/A'}`);\nconsole.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);\nconsole.log(`   üì° Signals: ${signalCount} emitted ‚Üí Neo4j`);\nsignalsEmitted.forEach(s => {\n  const icon = s.category === 'SystemSignal' ? '‚ö†Ô∏è' : '‚úÖ';\n  console.log(`      ${icon} ${s.signal_type}`);\n});\nconsole.log(`============================================================\\n`);\n\nreturn [{\n  json: output\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        2864
      ],
      "id": "4d15d4fa-becf-47a3-9c13-c5a373ba89e1",
      "name": "Final Output"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Qdrant Payload - Dual Standard + Tiers\n// v3.8: Added tier fields for filtering by primary/secondary expertise\n// Updates payload with BOTH Standard A and Standard B classification metadata\n\nconst inputData = $('Prepare Neo4j Write Query').item.json;\n\n// Get existing payload from Merge Embedding (preserves all researcher data)\nconst existingPayload = $('Merge Embedding').item.json;\n\n// ============================================================\n// v3.8: Extract Standard A classifications WITH TIER INFO\n// ============================================================\nconst classificationCodesA = inputData.classifications.map(c => parseInt(c.code, 10));\nconst classificationConfidencesA = inputData.classifications.map(c => c.confidence);\n\n// v3.8: Extract tiers and create filterable arrays\nconst classificationTiersA = inputData.classifications.map(c => c.tier || null);\nconst classificationRanksA = inputData.classifications.map(c => c.rank || null);\n\n// v3.8: Separate primary and secondary codes for easy filtering\nconst primaryCodes = inputData.classifications\n  .filter(c => c.tier === 'primary')\n  .map(c => parseInt(c.code, 10));\n\nconst secondaryCodes = inputData.classifications\n  .filter(c => c.tier === 'secondary')\n  .map(c => parseInt(c.code, 10));\n\n// Extract Standard B classification codes as strings\nconst classificationCodesB = (inputData.standard_b_classifications || []).map(c => c.code);\nconst classificationConfidencesB = (inputData.standard_b_classifications || []).map(c => c.confidence);\n\n// ============================================================\n// Build merged payload - preserve ALL existing fields, add classification fields\n// ============================================================\nconst mergedPayload = {\n  // Existing researcher data (preserve everything)\n  asset_id: existingPayload.asset_id,\n  object_type: \"researcher\",\n  name: existingPayload.name,\n  institution: existingPayload.institution,\n  orcid: existingPayload.orcid,\n  research_domains: existingPayload.research_domains || [],\n  methodologies: existingPayload.methodologies || [],\n  research_themes: existingPayload.research_themes || [],\n  h_index: existingPayload.h_index,\n  total_citations: existingPayload.total_citations,\n  publication_count: existingPayload.publication_count,\n  patent_count: existingPayload.patent_count,\n  career_stage: existingPayload.career_stage,\n  research_impact: existingPayload.research_impact,\n  data_completeness: existingPayload.data_completeness,\n  fabricated_at: existingPayload.fabricated_at,\n  \n  // Status update\n  status: \"classified\",\n  \n  // Standard A (ANZSRC) classification fields\n  classifications: classificationCodesA,\n  classification_confidences: classificationConfidencesA,\n  classification_taxonomy: \"ANZSRC_FoR_2020\",\n  \n  // ============================================================\n  // v3.8: TIER FIELDS (for Qdrant filtering)\n  // ============================================================\n  classification_tiers: classificationTiersA,\n  classification_ranks: classificationRanksA,\n  primary_codes: primaryCodes,\n  secondary_codes: secondaryCodes,\n  primary_code_count: primaryCodes.length,\n  secondary_code_count: secondaryCodes.length,\n  \n  // Standard B (OECD FOS) classification fields\n  standard_b_codes: classificationCodesB,\n  standard_b_confidences: classificationConfidencesB,\n  standard_b_taxonomy: \"OECD_FOS_2007\",\n  \n  // Combined confidence metrics\n  final_confidence: inputData.final_confidence,\n  cf1_passed: inputData.cf1_assessment?.passed || false,\n  crosswalk_alignment_score: inputData.crosswalk_assessment?.alignment_score || null,\n  \n  // Validation state\n  classified_at: inputData.classified_at,\n  classified_by: \"object3_classifier_v3.8.0\",\n  validation_state: \"PENDING\"\n};\n\n// Build Qdrant request\nconst qdrantPayload = {\n  payload: mergedPayload,\n  points: [inputData.qdrant_point_id]\n};\n\n// ============================================================\n// v3.8: Enhanced logging with tier info\n// ============================================================\nconsole.log(`‚úÖ Qdrant payload prepared (v3.8):`);\nconsole.log(`   Standard A: ${classificationCodesA.length} codes`);\nconsole.log(`   üìä Tiers: ${primaryCodes.length} primary + ${secondaryCodes.length} secondary`);\nconsole.log(`   Standard B: ${classificationCodesB.length} codes`);\n\nreturn [{\n  json: {\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    qdrant_point_id: inputData.qdrant_point_id,\n    classifications: inputData.classifications,\n    classification_count: inputData.classification_count,\n    // v3.8: Pass through tier summary\n    tier_summary: inputData.tier_summary || {\n      primary_count: primaryCodes.length,\n      secondary_count: secondaryCodes.length\n    },\n    standard_b_classifications: inputData.standard_b_classifications,\n    standard_b_count: inputData.standard_b_count,\n    final_confidence: inputData.final_confidence,\n    cf1_assessment: inputData.cf1_assessment,\n    crosswalk_assessment: inputData.crosswalk_assessment,\n    confidence_breakdown: inputData.confidence_breakdown,\n    reasoning: inputData.reasoning,\n    classified_at: inputData.classified_at,\n    qdrant_payload: qdrantPayload\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        2864
      ],
      "id": "0a5ec5c8-3866-4973-a8a4-48a4bfdb22df",
      "name": "Prepare Qdrant Payload"
    },
    {
      "parameters": {
        "jsCode": "// Node: Prepare Fetch FATObjects\n// PURPOSE: Fetch fabricated researchers with LIMIT for testing\n// FIXED: Maps OBJECT-2 schema to OBJECT-3 expected fields\nconst inputData = $input.first().json;\n\n// ============================================================\n// TEST MODE: Set limit for testing (null = fetch all)\n// ============================================================\nconst testLimit = 200; // Change to 3, 5, 10, or null for all\n\n// ============================================================\nlet cypherPayload;\n\nif (testLimit) {\n  cypherPayload = {\n    statement: `\n      MATCH (fat:FATObject:Researcher)\n      WHERE fat.status = 'fabricated'\n      OPTIONAL MATCH (fat)-[:AFFILIATED_WITH]->(org:Organisation)\n      RETURN \n          fat.asset_id AS asset_id,\n          fat.display_name AS name,\n          fat.orcid_id AS orcid,\n          org.display_name AS institution,\n          fat.dense_text AS dense_view,\n          fat.status AS status,\n          fat.version AS version,\n          fat.provenance AS provenance,\n          fat.updated_at AS fabricated_at\n      ORDER BY fat.updated_at DESC\n      LIMIT ${testLimit}\n    `,\n    parameters: {}\n  };\n  console.log(`üß™ TEST MODE: Fetching ${testLimit} researcher(s)`);\n} else {\n  cypherPayload = {\n    statement: `\n      MATCH (fat:FATObject:Researcher)\n      WHERE fat.status = 'fabricated'\n      OPTIONAL MATCH (fat)-[:AFFILIATED_WITH]->(org:Organisation)\n      RETURN \n          fat.asset_id AS asset_id,\n          fat.display_name AS name,\n          fat.orcid_id AS orcid,\n          org.display_name AS institution,\n          fat.dense_text AS dense_view,\n          fat.status AS status,\n          fat.version AS version,\n          fat.provenance AS provenance,\n          fat.updated_at AS fabricated_at\n      ORDER BY fat.updated_at DESC\n    `,\n    parameters: {}\n  };\n  console.log(`PRODUCTION MODE: Fetching ALL fabricated researchers`);\n}\n\nreturn [{\n  json: {\n    fetch_mode: testLimit ? `test_limit_${testLimit}` : 'all',\n    neo4j_payload: cypherPayload\n  }\n}];\n\n// // Node: Prepare Fetch FATObjects\n// // PURPOSE: Fetch specific researchers for testing\n// // FIXED: Maps OBJECT-2 schema to OBJECT-3 expected fields\n\n// const inputData = $input.first().json;\n\n// // ============================================================\n// // TEST MODE: Specify researchers to fetch\n// // ============================================================\n// const targetResearchers = [\n//   'fat:researcher:colin_barrow',\n//   'fat:researcher:richard_williams',\n//   'fat:researcher:ben_hankamer'\n// ];\n// // ============================================================\n\n// let cypherPayload;\n\n// if (targetResearchers && targetResearchers.length > 0) {\n//   cypherPayload = {\n//     statement: `\n//       MATCH (fat:FATObject:Researcher)\n//       WHERE fat.asset_id IN $target_ids\n//         AND fat.status = 'fabricated'\n//       OPTIONAL MATCH (fat)-[:AFFILIATED_WITH]->(org:Organisation)\n//       RETURN \n//           fat.asset_id AS asset_id,\n//           fat.display_name AS name,\n//           fat.orcid_id AS orcid,\n//           org.display_name AS institution,\n//           fat.dense_text AS dense_view,\n//           fat.status AS status,\n//           fat.version AS version,\n//           fat.provenance AS provenance,\n//           fat.updated_at AS fabricated_at\n//       ORDER BY fat.display_name\n//     `,\n//     parameters: {\n//       target_ids: targetResearchers\n//     }\n//   };\n//   console.log(`üéØ TARGET MODE: Fetching ${targetResearchers.length} specific researcher(s)`);\n//   console.log(`   ‚Üí ${targetResearchers.join(', ')}`);\n// } else {\n//   cypherPayload = {\n//     statement: `\n//       MATCH (fat:FATObject:Researcher)\n//       WHERE fat.status = 'fabricated'\n//       OPTIONAL MATCH (fat)-[:AFFILIATED_WITH]->(org:Organisation)\n//       RETURN \n//           fat.asset_id AS asset_id,\n//           fat.display_name AS name,\n//           fat.orcid_id AS orcid,\n//           org.display_name AS institution,\n//           fat.dense_text AS dense_view,\n//           fat.status AS status,\n//           fat.version AS version,\n//           fat.provenance AS provenance,\n//           fat.updated_at AS fabricated_at\n//       ORDER BY fat.updated_at DESC\n//     `,\n//     parameters: {}\n//   };\n//   console.log(`üìã PRODUCTION MODE: Fetching ALL fabricated researchers`);\n// }\n\n// return [{\n//   json: {\n//     fetch_mode: targetResearchers.length > 0 ? `target_${targetResearchers.length}` : 'all',\n//     target_researchers: targetResearchers,\n//     neo4j_payload: cypherPayload\n//   }\n// }];\n// // }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        1968
      ],
      "id": "f8aa0c30-c8ba-4c3d-9f28-4a5ac950d0fa",
      "name": "Prepare Fetch FATObjects"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_status_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1824,
        1968
      ],
      "id": "fd4a4b59-0db2-4468-884e-339a824d77d8",
      "name": "Execute Status Update to Classifying",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Verify status was updated, then pass through original data\nconst neo4jResponse = $input.first().json;\nconst originalData = $('Prepare Status Update to Classifying').item.json;\n\n// Check update succeeded\nconst values = neo4jResponse.data?.values || [];\nif (values.length === 0) {\n  throw new Error('Failed to update status to classifying');\n}\n\nconst updatedStatus = values[0][1];\nif (updatedStatus !== 'classifying') {\n  throw new Error(`Expected status 'classifying', got '${updatedStatus}'`);\n}\n\n// Pass through original data with confirmed status\nreturn [{\n  json: {\n    ...originalData,\n    status: 'classifying',  // Confirmed updated\n    classification_started_at: new Date().toISOString()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2032,
        1968
      ],
      "id": "d419ff9f-a0f4-44ff-9235-296fd521dd73",
      "name": "Parse Status Update Response"
    },
    {
      "parameters": {
        "jsCode": "// Add this node AFTER \"Parse Neo4j Response\"\nconst inputData = $input.first().json;\n\nreturn [{\n  json: {\n    ...inputData,\n    neo4j_status_payload: {\n      statement: `\n        MATCH (fat:FATObject {asset_id: $asset_id})\n        SET fat.status = 'classifying',\n            fat.classification_started_at = datetime()\n        RETURN fat.asset_id, fat.status\n      `,\n      parameters: {\n        asset_id: inputData.asset_id\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1568,
        1968
      ],
      "id": "8c3d8df6-22a5-4fac-92cb-611d59d762de",
      "name": "Prepare Status Update to Classifying"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Crosswalk Assessment Query\n// v3.7.2 FIX: ALWAYS include neo4j_payload to prevent HTTP node error\n\nconst inputData = $input.first().json;\n\n// Safely get classifications (handle undefined/null)\nconst classifications = inputData.classifications || [];\nconst standardBClassifications = inputData.standard_b_classifications || [];\n\nconst standardACodes = classifications.map(c => parseInt(c.code, 10));\nconst standardBCodes = standardBClassifications.map(c => c.code);\n\n// If no Standard B OR no Standard A classifications, skip crosswalk assessment\nif (standardBCodes.length === 0 || standardACodes.length === 0) {\n  const reason = standardACodes.length === 0 \n    ? 'No Standard A classifications' \n    : 'No Standard B classifications';\n  \n  console.log(`‚ö†Ô∏è ${reason} - skipping crosswalk assessment`);\n  \n  // ‚úÖ FIX: ALWAYS include neo4j_payload so HTTP node doesn't fail\n  return [{\n    json: {\n      ...inputData,\n      crosswalk_assessment: {\n        skipped: true,\n        reason: reason,\n        alignment_score: null,\n        modifier: 0\n      },\n      neo4j_payload: {\n        statement: \"RETURN 'skipped' AS status\",\n        parameters: {}\n      }\n    }\n  }];\n}\n\n// Normal path: Query crosswalk relationships\nconst cypherPayload = {\n  statement: `\n    UNWIND $anzsrc_codes AS anzsrc_code\n    MATCH (a:Standard:FoR {code: anzsrc_code})\n    OPTIONAL MATCH (a)-[m:MAPS_TO_V4]->(b:Standard:OECD_FOS:DomainHub)\n    RETURN \n      a.code AS anzsrc_code,\n      a.name AS anzsrc_name,\n      collect(CASE WHEN b IS NOT NULL THEN {\n        fos_code: b.code,\n        fos_name: b.name,\n        confidence: m.confidence,\n        alignment_score: m.alignment_score,\n        mapping_type: m.mapping_type\n      } ELSE NULL END) AS mapped_fos_codes\n  `,\n  parameters: {\n    anzsrc_codes: standardACodes\n  }\n};\n\nreturn [{\n  json: {\n    ...inputData,\n    standard_a_codes: standardACodes,\n    standard_b_codes: standardBCodes,\n    neo4j_payload: cypherPayload\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        2592
      ],
      "id": "2ec0878f-4120-4b58-81fd-abb0d5d3c674",
      "name": "Prepare Crosswalk Assessment Query"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        544,
        2592
      ],
      "id": "4620f0dd-b2f9-4031-9385-fca52c12527f",
      "name": "Execute Crosswalk Assessment",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Calculate Crosswalk Alignment Score (FIXED)\n// v3.6.2 FIX: Code-level alignment instead of mapping-level\n// \n// OLD (flawed): alignedMappings / totalMappings\n//   - If code maps to 5 FOS and only 1 matches, that's 20% per code\n//   - Unfairly penalizes codes with many crosswalk relationships\n//\n// NEW (fixed): codesWithMatch / codesChecked  \n//   - If code has ANY matching FOS, it counts as aligned\n//   - Fair assessment: \"Does this ANZSRC code align with assigned FOS?\"\n\nconst neo4jResponse = $input.first().json;\nconst prevData = $('Prepare Crosswalk Assessment Query').item.json;\n\n// Handle skipped assessment\nif (prevData.crosswalk_assessment?.skipped) {\n  return [{ json: prevData }];\n}\n\n// Parse Neo4j response\nconst responseData = Array.isArray(neo4jResponse) ? neo4jResponse[0] : neo4jResponse;\n\nif (responseData.errors?.length > 0) {\n  console.error('Neo4j error:', responseData.errors[0].message);\n  return [{\n    json: {\n      ...prevData,\n      crosswalk_assessment: {\n        error: responseData.errors[0].message,\n        alignment_score: null,\n        modifier: 0.0\n      }\n    }\n  }];\n}\n\nconst values = responseData.data?.values || [];\nconst assignedFosCodes = new Set(prevData.standard_b_codes);\n\n// ============================================================\n// v3.6.2 FIX: Track CODE-LEVEL alignment (not mapping-level)\n// ============================================================\nlet codesWithMatch = 0;\nlet codesChecked = 0;\nlet codesWithNoCrosswalk = 0;\n\n// Still track mapping-level for detailed reporting\nlet totalMappings = 0;\nlet alignedMappings = 0;\n\nconst alignmentDetails = [];\n\nfor (const row of values) {\n  const anzsrcCode = row[0];\n  const anzsrcName = row[1];\n  const mappedFosCodes = (row[2] || []).filter(m => m !== null);\n  \n  if (mappedFosCodes.length === 0) {\n    // No crosswalk exists for this code\n    codesWithNoCrosswalk += 1;\n    alignmentDetails.push({\n      anzsrc_code: anzsrcCode,\n      anzsrc_name: anzsrcName,\n      status: 'no_crosswalk',\n      mapped_fos: [],\n      aligned: false\n    });\n    continue;\n  }\n  \n  // This code has crosswalks - count it for alignment calculation\n  codesChecked += 1;\n  \n  // Check if ANY mapped FOS code matches an assigned FOS code\n  const matchingMappings = mappedFosCodes.filter(m => assignedFosCodes.has(m.fos_code));\n  const hasMatch = matchingMappings.length > 0;\n  \n  if (hasMatch) {\n    codesWithMatch += 1;\n  }\n  \n  // Track individual mappings for detailed reporting\n  totalMappings += mappedFosCodes.length;\n  alignedMappings += matchingMappings.length;\n  \n  alignmentDetails.push({\n    anzsrc_code: anzsrcCode,\n    anzsrc_name: anzsrcName,\n    status: hasMatch ? 'aligned' : 'misaligned',\n    mapped_fos: mappedFosCodes.map(m => ({\n      code: m.fos_code,\n      name: m.fos_name,\n      confidence: m.confidence,\n      matches_assigned: assignedFosCodes.has(m.fos_code)\n    })),\n    aligned: hasMatch,\n    matching_count: matchingMappings.length,\n    total_mappings: mappedFosCodes.length\n  });\n}\n\n// ============================================================\n// v3.6.2 FIX: CODE-LEVEL alignment score\n// Question: \"What % of ANZSRC codes have at least one matching FOS?\"\n// ============================================================\nlet alignmentScore = codesChecked > 0 \n  ? Math.round((codesWithMatch / codesChecked) * 100) / 100 \n  : null;\n\n// Also calculate mapping-level for reference (but don't use for modifier)\nlet mappingLevelScore = totalMappings > 0\n  ? Math.round((alignedMappings / totalMappings) * 100) / 100\n  : null;\n\n// ============================================================\n// Three-tier modifier system (unchanged thresholds)\n// ============================================================\n// >= 0.50: Strong alignment   ‚Üí +5% boost\n// 0.30 - 0.49: Acceptable     ‚Üí 0% neutral\n// < 0.30: Poor alignment      ‚Üí -15% penalty\n// ============================================================\n\nlet modifier = 0.0;\nlet alignmentStatus = 'unknown';\n\nif (alignmentScore === null) {\n  // No crosswalks exist (Gen 2 fallback)\n  modifier = 0.0;\n  alignmentStatus = 'no_crosswalks';\n} else if (alignmentScore >= 0.50) {\n  // Strong alignment: boost confidence\n  modifier = 0.05;\n  alignmentStatus = 'aligned';\n} else if (alignmentScore >= 0.30) {\n  // Acceptable alignment: neutral (no penalty, no boost)\n  modifier = 0.0;\n  alignmentStatus = 'acceptable';\n} else {\n  // Poor alignment: penalize confidence\n  modifier = -0.15;\n  alignmentStatus = 'misaligned';\n}\n\n// Detailed logging\nconsole.log(`‚úÖ Crosswalk Assessment (v3.6.2 - code-level):`);\nconsole.log(`   ANZSRC codes checked: ${codesChecked}`);\nconsole.log(`   Codes with FOS match: ${codesWithMatch}`);\nconsole.log(`   Codes with no crosswalk: ${codesWithNoCrosswalk}`);\nconsole.log(`   CODE-LEVEL alignment: ${alignmentScore !== null ? (alignmentScore * 100).toFixed(0) + '%' : 'N/A'}`);\nconsole.log(`   (mapping-level was: ${mappingLevelScore !== null ? (mappingLevelScore * 100).toFixed(0) + '%' : 'N/A'})`);\nconsole.log(`   Status: ${alignmentStatus}`);\nconsole.log(`   Modifier: ${modifier >= 0 ? '+' : ''}${(modifier * 100).toFixed(0)}%`);\n\n// Log which codes aligned and which didn't\nconst alignedCodes = alignmentDetails.filter(d => d.aligned);\nconst misalignedCodes = alignmentDetails.filter(d => d.status === 'misaligned');\nif (alignedCodes.length > 0) {\n  console.log(`   Aligned: ${alignedCodes.map(d => d.anzsrc_code).join(', ')}`);\n}\nif (misalignedCodes.length > 0) {\n  console.log(`   Misaligned: ${misalignedCodes.map(d => d.anzsrc_code).join(', ')}`);\n}\n\nreturn [{\n  json: {\n    // Core data\n    asset_id: prevData.asset_id,\n    name: prevData.name,\n    qdrant_point_id: prevData.qdrant_point_id,\n    \n    // Classifications\n    classifications: prevData.classifications,\n    classification_count: prevData.classification_count,\n    standard_b_classifications: prevData.standard_b_classifications,\n    standard_b_count: prevData.standard_b_count,\n    reasoning: prevData.reasoning,\n    model: prevData.model,\n    \n    // Crosswalk assessment (v3.6.2 - code-level)\n    crosswalk_assessment: {\n      skipped: false,\n      \n      // PRIMARY: Code-level alignment (used for modifier)\n      alignment_score: alignmentScore,\n      alignment_status: alignmentStatus,\n      modifier: modifier,\n      \n      // Code-level stats\n      codes_checked: codesChecked,\n      codes_with_match: codesWithMatch,\n      codes_with_no_crosswalk: codesWithNoCrosswalk,\n      \n      // Mapping-level stats (for reference only)\n      total_mappings_checked: totalMappings,\n      aligned_mappings: alignedMappings,\n      mapping_level_score: mappingLevelScore,\n      \n      // Detailed breakdown\n      details: alignmentDetails\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        2592
      ],
      "id": "44ae3766-6e39-4320-abaa-518d3a9a0ff9",
      "name": "Calculate Crosswalk Alignment"
    },
    {
      "parameters": {
        "jsCode": "// Prepare PostgreSQL Classification Log\n// Creates audit record for classification job\n\nconst inputData = $('Prepare Qdrant Payload').item.json;\n\n// Generate classification job ID\nconst jobId = `clf_${inputData.asset_id.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;\n\nconst postgresPayload = {\n  job_id: jobId,\n  asset_id: inputData.asset_id,\n  asset_type: 'researcher',\n  \n  // Standard A summary\n  standard_a_taxonomy: 'ANZSRC_FoR_2020',\n  standard_a_codes: inputData.classifications.map(c => parseInt(c.code, 10)),\n  standard_a_count: inputData.classification_count,\n  \n  // Standard B summary\n  standard_b_taxonomy: 'OECD_FOS_2007',\n  standard_b_codes: (inputData.standard_b_classifications || []).map(c => c.code),\n  standard_b_count: inputData.standard_b_count || 0,\n  \n  // Confidence metrics\n  final_confidence: inputData.final_confidence,\n  cf1_passed: inputData.cf1_assessment?.passed || false,\n  cf1_penalty: inputData.cf1_assessment?.penalty || 0,\n  crosswalk_alignment_score: inputData.crosswalk_assessment?.alignment_score || null,\n  crosswalk_modifier: inputData.crosswalk_assessment?.modifier || 0,\n  \n  // Metadata\n  classified_at: inputData.classified_at,\n  classified_by: 'object3_classifier_v3.5',\n  model: 'openai/gpt-oss-120b',\n  workflow_version: 'OBJECT-3_v3.6',\n  \n  // Routing preview (for OBJECT-4)\n  routing_recommendation: inputData.final_confidence >= 0.85 \n    ? 'AUTO_APPROVE' \n    : inputData.final_confidence >= 0.60 \n      ? 'HUMAN_REVIEW' \n      : 'REJECT'\n};\n\nreturn [{\n  json: {\n    ...inputData,\n    postgres_payload: postgresPayload\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        832,
        2864
      ],
      "id": "19756f8b-fe75-45d0-b670-e2eb9df4109e",
      "name": "Prepare PostgreSQL Classification Log"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://esgwrqcyhtzcsbepvqhc.supabase.co/rest/v1/classification_logs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "prefer",
              "value": "resolution=merge-duplicates,return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.postgres_payload }}",
        "options": {
          "timeout": 30000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1088,
        2864
      ],
      "id": "3d0bb997-6b39-46c0-96df-b93b07bbbc14",
      "name": "Store Crosswalk Metadata",
      "credentials": {
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        },
        "supabaseApi": {
          "id": "vTKATqGswB3PHE6S",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// CF1 Hierarchical Consistency Check\n// Validates classification hierarchy and checks for constraint violations\n// UPDATED: Handle empty classifications gracefully\n// ============================================================\n\nconst inputData = $input.first().json;\n\n// === Handle empty classifications (candidate mismatch) ===\nif (!inputData.classifications || inputData.classifications.length === 0) {\n  console.log(`‚ö†Ô∏è No ANZSRC classifications for ${inputData.name} - routing to HITL`);\n  \n  // Check if we have Standard B classifications (OECD FOS)\n  const hasStandardB = inputData.standard_b_classifications && \n                       inputData.standard_b_classifications.length > 0;\n  \n  return [{\n    json: {\n      // Core data (pass through)\n      asset_id: inputData.asset_id,\n      name: inputData.name,\n      qdrant_point_id: inputData.qdrant_point_id,\n      reasoning: inputData.reasoning,\n      model: inputData.model,\n      \n      // Crosswalk assessment (pass through)\n      crosswalk_assessment: inputData.crosswalk_assessment,\n      \n      // CRE assessment (pass through)\n      cre_assessment: inputData.cre_assessment,\n      \n      // Standard B classifications (pass through)\n      standard_b_classifications: inputData.standard_b_classifications,\n      standard_b_count: inputData.standard_b_count,\n      \n      // Empty Standard A - this is the problem\n      classifications: [],\n      classification_count: 0,\n      \n      // CF1 Assessment - mark as failed due to no classifications\n      cf1_assessment: {\n        passed: false,\n        violations: [],\n        flags: [{\n          rule: 'no_anzsrc_classifications',\n          message: 'LLM could not assign any ANZSRC codes from candidates - likely candidate mismatch',\n          has_standard_b: hasStandardB,\n          standard_b_count: inputData.standard_b_count || 0\n        }],\n        penalty: 0.5,\n        divisions_found: [],\n        groups_found: []\n      },\n      \n      // Route to HITL\n      requires_hitl: true,\n      hitl_reason: 'No ANZSRC classifications - vector search returned irrelevant candidates',\n      classification_failed: false,\n      candidate_mismatch: true\n    }\n  }];\n}\n\n// === Normal processing continues below ===\n\n// Extract hierarchy info from each code\nconst classificationDetails = inputData.classifications.map(c => {\n  const code = String(c.code);\n  return {\n    ...c,\n    division_code: code.substring(0, 2),\n    group_code: code.substring(0, 4),\n    field_code: code\n  };\n});\n\n// Get unique divisions and groups\nconst divisionsFound = [...new Set(classificationDetails.map(c => c.division_code))];\nconst groupsFound = [...new Set(classificationDetails.map(c => c.group_code))];\n\n// === CF1 RULE 1: Check parent-child conflicts ===\nconst violations = [];\nconst codes = classificationDetails.map(c => c.code);\n\nfor (const c of classificationDetails) {\n  for (const other of codes) {\n    if (other !== c.code) {\n      if (c.code.startsWith(other) && c.code.length > other.length) {\n        violations.push({\n          rule: 'parent_child_conflict',\n          parent: other,\n          child: c.code,\n          action: `Remove parent code ${other}, keep specific code ${c.code}`\n        });\n      }\n    }\n  }\n}\n\n// === CF1 RULE 2: Check code specificity (warn on broad codes) ===\nconst flags = [];\nfor (const c of classificationDetails) {\n  if (c.code.length === 2) {\n    flags.push({\n      rule: 'broad_code_warning',\n      code: c.code,\n      message: '2-digit code is very broad, consider more specific classification'\n    });\n  } else if (c.code.length === 4) {\n    flags.push({\n      rule: 'group_code_warning',\n      code: c.code,\n      message: '4-digit group code used instead of 6-digit field code'\n    });\n  }\n}\n\n// === CF1 RULE 3: Check sibling overlap ===\nconst parentGroups = {};\nfor (const c of classificationDetails) {\n  if (c.code.length === 6) {\n    const parent = c.group_code;\n    if (!parentGroups[parent]) {\n      parentGroups[parent] = [];\n    }\n    parentGroups[parent].push(c.code);\n  }\n}\n\nfor (const [parent, children] of Object.entries(parentGroups)) {\n  if (children.length > 2) {\n    flags.push({\n      rule: 'sibling_overlap',\n      parent: parent,\n      siblings: children,\n      message: `Multiple codes (${children.length}) under group ${parent} may indicate over-classification`\n    });\n  }\n}\n\n// === Calculate penalty ===\nlet penalty = 0.0;\npenalty += violations.length * 0.10;\npenalty += flags.filter(f => f.rule === 'broad_code_warning').length * 0.05;\n\nconst passed = violations.length === 0;\n\n// === Build adjusted classifications ===\nconst codesToRemove = new Set(violations.map(v => v.parent));\n\nconst adjustedClassifications = classificationDetails\n  .filter(c => !codesToRemove.has(c.code))\n  .map(c => ({\n    code: c.code,\n    name: c.name,\n    confidence: c.confidence,\n    justification: c.justification,\n    evidence: c.evidence,\n    division_code: c.division_code,\n    group_code: c.group_code,\n    cf1_validated: passed\n  }));\n\n// === Enforce min/max code counts ===\nconst MIN_CODES = 3;\nconst MAX_CODES = 10;\n\nif (adjustedClassifications.length < MIN_CODES) {\n  flags.push({\n    rule: 'under_classification',\n    count: adjustedClassifications.length,\n    message: `Only ${adjustedClassifications.length} codes assigned, minimum is ${MIN_CODES}`\n  });\n}\n\nif (adjustedClassifications.length > MAX_CODES) {\n  adjustedClassifications.sort((a, b) => b.confidence - a.confidence);\n  adjustedClassifications.splice(MAX_CODES);\n  flags.push({\n    rule: 'over_classification_truncated',\n    message: `Truncated to ${MAX_CODES} highest-confidence codes`\n  });\n}\n\nconsole.log(`‚úÖ CF1 Assessment: ${passed ? 'PASSED' : 'FAILED'}`);\nconsole.log(`   Violations: ${violations.length}, Flags: ${flags.length}, Penalty: ${penalty}`);\n\nreturn [{\n  json: {\n    // Core data (pass through)\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    qdrant_point_id: inputData.qdrant_point_id,\n    reasoning: inputData.reasoning,\n    model: inputData.model,\n    \n    // Crosswalk assessment (pass through)\n    crosswalk_assessment: inputData.crosswalk_assessment,\n    \n    // CRE assessment (pass through)\n    cre_assessment: inputData.cre_assessment,\n    \n    // Standard B classifications (pass through)\n    standard_b_classifications: inputData.standard_b_classifications,\n    standard_b_count: inputData.standard_b_count,\n    \n    // CF1 Assessment results\n    cf1_assessment: {\n      passed: passed,\n      violations: violations,\n      flags: flags,\n      penalty: penalty,\n      divisions_found: divisionsFound,\n      groups_found: groupsFound\n    },\n    \n    // Adjusted Standard A classifications\n    classifications: adjustedClassifications,\n    classification_count: adjustedClassifications.length,\n    \n    // Normal path - no HITL override\n    requires_hitl: false,\n    candidate_mismatch: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        2592
      ],
      "id": "3d5d0caa-bf9a-4182-99ce-f97e0fdee6a5",
      "name": "ANZSRC Hierarchy Check"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "7wgDbsjDcjLdQNSJ",
          "mode": "id",
          "cachedResultUrl": "/workflow/7wgDbsjDcjLdQNSJ"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1328,
        2592
      ],
      "name": "SYSTEM-2_CRE_Assessment",
      "id": "e73bca7f-8978-4da4-aac9-43e61dbb0f5a"
    },
    {
      "parameters": {
        "jsCode": "// Merge CRE Output\nconst creOutput = $input.first().json;  // From SYSTEM-2\nconst prevData = $('Calculate Crosswalk Alignment').item.json;  // Get data from before CRE\n\nconsole.log(`‚úÖ CRE Assessment Received:`);\nconsole.log(`   Blocking: ${creOutput.blocking_failures?.join(', ') || 'None'}`);\nconsole.log(`   HITL Required: ${creOutput.requires_hitl}`);\n\nreturn [{\n  json: {\n    // Pass through from earlier node\n    asset_id: prevData.asset_id,\n    name: prevData.name,\n    qdrant_point_id: prevData.qdrant_point_id,\n    classifications: prevData.classifications,\n    classification_count: prevData.classification_count,\n    standard_b_classifications: prevData.standard_b_classifications,\n    standard_b_count: prevData.standard_b_count,\n    reasoning: prevData.reasoning,\n    model: prevData.model,\n    crosswalk_assessment: prevData.crosswalk_assessment,\n    \n    // CRE Assessment (from SYSTEM-2)\n    cre_assessment: {\n      constraint_results: creOutput.constraint_results || {},\n      blocking_failures: creOutput.blocking_failures || [],\n      penalising_failures: creOutput.penalising_failures || [],\n      requires_hitl: creOutput.requires_hitl || false,\n      cre_penalty: Math.abs(creOutput.final_confidence_modifier || 0)\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        2592
      ],
      "id": "b45913b9-b37e-4c54-b9bd-4505b4c3b3c9",
      "name": "Merge CRE Output"
    },
    {
      "parameters": {
        "jsCode": "// Prepare CRE Input\n// Gen 4: Build input contract for SYSTEM-2_CRE_Assessment sub-workflow\n\nconst inputData = $input.first().json;\nconst signals = $('Merge Embedding').item.json;\n\n// Infer TRL from researcher signals\nfunction inferTRLLevel(s) {\n  const hasPatents = (s.patent_count || 0) > 0;\n  const careerStage = (s.career_stage || '').toLowerCase();\n  const impact = (s.research_impact || '').toLowerCase();\n  \n  if (hasPatents && (careerStage === 'established' || careerStage === 'senior')) return 7;\n  if (impact === 'leading' || impact === 'high') return 6;\n  if (careerStage === 'mid-career' || (s.h_index || 0) > 20) return 5;\n  if (careerStage === 'early-career' || careerStage === 'emerging') return 3;\n  return 4;\n}\n\n// Determine inference type\n// Only use 'patent' or 'publication' if NO explicit expertise declared\nlet inference_type = 'explicit';\n\nconst hasExplicitExpertise = \n  (signals.research_domains?.length > 0) ||\n  (signals.methodologies?.length > 0) ||\n  (signals.research_themes?.length > 0);\n\nif (!hasExplicitExpertise) {\n  // No explicit declaration - infer from other signals\n  if ((signals.patent_count || 0) > 0) {\n    inference_type = 'patent';\n  } else if ((signals.publication_count || 0) > 0) {\n    inference_type = 'publication';\n  } else {\n    inference_type = 'keyword';\n  }\n}\n\n// Average classification confidence\nconst avgConfidence = inputData.classifications.length > 0\n  ? inputData.classifications.reduce((a, c) => a + c.confidence, 0) / inputData.classifications.length\n  : 0;\n\n// Output CRE contract at ROOT level\nreturn [{\n  json: {\n    asset_id: inputData.asset_id,\n    classification_confidence: avgConfidence,\n    entity_data: {\n      trl_level: inferTRLLevel(signals),\n      certifications: [],\n      inference_type: inference_type\n    },\n    requirements: {\n      required_trl: 5,\n      required_certifications: []\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1072,
        2592
      ],
      "id": "80139a7d-c20b-4eea-8298-98f24492acac",
      "name": "Prepare CRE Input"
    },
    {
      "parameters": {
        "model": "anthropic/claude-opus-4.5",
        "options": {
          "temperature": 0,
          "topP": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2624,
        2480
      ],
      "id": "7c79fe58-a190-4ed4-8910-741ef0e3c07b",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare FOS Vector Search (Standard B)\n// Uses direct reference to get embedding from source node\n\nconst inputData = $input.first().json;\n\n// Get embedding directly from \"Merge Embedding\" node\nconst mergeEmbeddingData = $('Merge Embedding').item.json;\nconst embeddingVector = mergeEmbeddingData.embedding_vector;\n\n// Validate embedding\nif (!embeddingVector || embeddingVector.length !== 3072) {\n  throw new Error(`Invalid embedding vector from Merge Embedding. Expected 3072 dimensions, got ${embeddingVector?.length || 0}`);\n}\n\n// ============================================================\n// OECD FOS collection already contains ONLY FOS codes\n// No need to filter by taxonomy - the collection IS the filter\n// ============================================================\nconst qdrantFosRequest = {\n  query: embeddingVector,\n  limit: 10,\n  with_payload: true,\n  with_vector: false\n  // No filter needed - collection is dedicated to FOS\n};\n\nreturn [{\n  json: {\n    // Pass through all data from previous node\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    orcid: inputData.orcid,\n    institution: inputData.institution,\n    qdrant_point_id: inputData.qdrant_point_id,\n    dense_view_text: inputData.dense_view_text,\n    research_domains: inputData.research_domains,\n    methodologies: inputData.methodologies,\n    research_themes: inputData.research_themes,\n    h_index: inputData.h_index,\n    career_stage: inputData.career_stage,\n    \n    // ANZSRC candidates (Standard A) - from reranking\n    field_candidates: inputData.field_candidates,\n    field_candidate_count: inputData.field_candidate_count,\n    reranking: inputData.reranking,\n    group_candidates: inputData.group_candidates,\n    retrieval_sources: inputData.retrieval_sources,\n    \n    // Store embedding for reference\n    embedding_vector: embeddingVector,\n    \n    // Qdrant request for FOS search (no filter)\n    qdrant_fos_request: qdrantFosRequest\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1632,
        2256
      ],
      "id": "c6e9c9b6-39eb-4f3a-a752-9fedfd9e918d",
      "name": "Prepare FOS Vector Search"
    },
    {
      "parameters": {
        "jsCode": "// Parse FOS Vector Search Results\n// Extracts OECD FOS candidates for dual-standard classification\n\nconst qdrantResponse = $input.first().json;\nconst originalData = $('Prepare FOS Vector Search').item.json;\n\n// Handle response structure (may be wrapped in array)\nconst responseData = Array.isArray(qdrantResponse) ? qdrantResponse[0] : qdrantResponse;\n\n// ============================================================\n// FAIL-SAFE: Handle errors or empty results\n// ============================================================\nif (responseData.status === 'error' || responseData.error) {\n  const errorMessage = responseData.status?.error || responseData.error || 'Unknown error';\n  console.log(`‚ö†Ô∏è FOS Vector Search error: ${errorMessage}`);\n  \n  return [{\n    json: {\n      ...originalData,\n      fos_candidates: [],\n      fos_candidate_count: 0,\n      fos_search_empty: true,\n      fos_search_error: errorMessage\n    }\n  }];\n}\n\nconst points = responseData.result?.points || [];\n\nif (points.length === 0) {\n  console.log('‚ö†Ô∏è FOS Vector Search: No candidates found - proceeding with ANZSRC only');\n  \n  return [{\n    json: {\n      ...originalData,\n      fos_candidates: [],\n      fos_candidate_count: 0,\n      fos_search_empty: true\n    }\n  }];\n}\n\n// Extract FOS candidates with scores and context\n// Filter to field-level only (exclude group-level like \"2\", \"3\")\nconst fosCandidates = points\n  .filter(point => point.payload.level === 'field')  // Only fields, not groups\n  .map(point => ({\n    code: point.payload.code,\n    name: point.payload.name,\n    score: point.score,\n    group_code: point.payload.group_code,\n    embedding_text: point.payload.embedding_text || null\n  }));\n\n// Log summary\nconsole.log(`‚úÖ FOS Vector Search: Found ${fosCandidates.length} field-level candidates`);\nconsole.log(`   Top 3: ${fosCandidates.slice(0, 3).map(c => `${c.code} ${c.name} (${c.score.toFixed(3)})`).join(', ')}`);\n\nreturn [{\n  json: {\n    // Pass through ALL researcher data\n    asset_id: originalData.asset_id,\n    name: originalData.name,\n    orcid: originalData.orcid,\n    institution: originalData.institution,\n    qdrant_point_id: originalData.qdrant_point_id,\n    dense_view_text: originalData.dense_view_text,\n    research_domains: originalData.research_domains,\n    methodologies: originalData.methodologies,\n    research_themes: originalData.research_themes,\n    h_index: originalData.h_index,\n    career_stage: originalData.career_stage,\n    \n    // ANZSRC candidates (Standard A) - from reranking\n    field_candidates: originalData.field_candidates,\n    field_candidate_count: originalData.field_candidate_count,\n    reranking: originalData.reranking,\n    group_candidates: originalData.group_candidates,\n    retrieval_sources: originalData.retrieval_sources,\n    \n    // NEW: FOS candidates (Standard B)\n    fos_candidates: fosCandidates,\n    fos_candidate_count: fosCandidates.length,\n    fos_search_empty: false\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        2256
      ],
      "id": "fa4ab0f0-c4d5-47a5-ad4d-ce651d44865b",
      "name": "Parse FOS Candidates"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/standards_oecd_fos_2007/points/query",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.qdrant_fos_request) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "cc98f942-aaf7-48cb-823b-943428415106",
      "name": "Vector Search FOS (Qdrant)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1920,
        2256
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Prepare Dual-Standard LLM Prompt\n// Version: v3.7.3\n// Aligned with: researcher_instance_spec_v2.2, OBJECT-3_Definition_Card_v3.7\n// FIX v3.7.3: Fetch dense_view_parsed directly from Merge Embedding node\n//             (intermediate vector search nodes don't pass it through)\n// ============================================================\n\nconst inputData = $input.first().json;\n\n// ============================================================\n// v3.7.3 FIX: Fetch dense_view_parsed directly from Merge Embedding\n// This ensures publications are available regardless of what\n// intermediate nodes (vector search) pass through\n// ============================================================\nlet denseViewParsed = {};\ntry {\n  const mergeEmbeddingData = $('Merge Embedding').item.json;\n  denseViewParsed = mergeEmbeddingData.dense_view_parsed || {};\n  console.log(`‚úÖ Fetched dense_view_parsed from Merge Embedding`);\n  console.log(`   Publications found: ${(denseViewParsed.raw_evidence?.publications || []).length}`);\n} catch (e) {\n  // Fallback to input data if Merge Embedding not accessible\n  console.log(`‚ö†Ô∏è Could not fetch from Merge Embedding: ${e.message}`);\n  console.log(`   Falling back to inputData.raw_evidence`);\n  denseViewParsed = inputData.dense_view_parsed || {};\n}\n\n// Get ANZSRC field candidates (Standard A) - Top 25 from reranking\nconst anzsrcCandidates = inputData.field_candidates || [];\n\n// Get FOS candidates (Standard B)\nconst fosCandidates = inputData.fos_candidates || [];\n\n// ============================================================\n// EXTRACT RAW EVIDENCE (v3.7.3 - from denseViewParsed first)\n// ============================================================\nconst rawEvidence = denseViewParsed.raw_evidence || inputData.raw_evidence || {};\nconst enrichedContext = denseViewParsed.enriched_context || inputData.enriched_context || {};\n\nconst publications = rawEvidence.publications || [];\nconst grants = rawEvidence.grants || [];\nconst biography = rawEvidence.biography || '';\nconst researchInterests = rawEvidence.research_interests || [];\n\n// Log what we found for debugging\nconsole.log(`üìä Evidence extracted for ${inputData.name}:`);\nconsole.log(`   Publications: ${publications.length}`);\nconsole.log(`   Grants: ${grants.length}`);\nconsole.log(`   Biography length: ${biography.length} chars`);\nconsole.log(`   Research interests: ${researchInterests.length}`);\nif (publications.length > 0) {\n  console.log(`   First pub: \"${publications[0].title}\" (${publications[0].year || 'no year'})`);\n}\n\n// ============================================================\n// FORMAT PUBLICATIONS FOR PROMPT (Top 15)\n// v3.7.3: Include year and citations in output\n// ============================================================\nconst pubList = publications.slice(0, 15).map((p, i) => {\n  const title = p.title || 'Untitled';\n  const year = p.year ? ` (${p.year})` : '';\n  const citations = p.citations ? ` [${p.citations} citations]` : '';\n  const abstract = p.abstract ? `\\n     Abstract: ${p.abstract.slice(0, 200)}...` : '';\n  const keywords = (p.keywords || []).slice(0, 5).join(', ');\n  return `  ${i+1}. ${title}${year}${citations}${abstract}${keywords ? `\\n     Keywords: ${keywords}` : ''}`;\n}).join('\\n');\n\n// ============================================================\n// FORMAT GRANTS FOR PROMPT\n// ============================================================\nconst grantList = grants.slice(0, 10).map((g, i) => {\n  const title = g.title || 'Untitled Grant';\n  const funder = g.funder ? ` (${g.funder})` : '';\n  const amount = g.amount ? ` - $${Number(g.amount).toLocaleString()}` : '';\n  const dates = g.dates ? ` [${g.dates}]` : '';\n  return `  ${i+1}. ${title}${funder}${amount}${dates}`;\n}).join('\\n');\n\n// ============================================================\n// BUILD ANZSRC CANDIDATE LIST (Standard A)\n// ============================================================\nconst anzsrcList = anzsrcCandidates.map(f => {\n  return `  ${f.code} - ${f.name}`;\n}).join('\\n');\n\n// ============================================================\n// BUILD FOS CANDIDATE LIST (Standard B)\n// ============================================================\nconst fosList = fosCandidates.map(f => {\n  return `  ${f.code} - ${f.name}`;\n}).join('\\n');\n\n// ============================================================\n// DETERMINE CODE COUNT BASED ON CAREER STAGE\n// Per researcher_instance_spec_v2.2 Section 4.3\n// ============================================================\nconst careerStage = inputData.career_stage || enrichedContext.career_stage || 'mid-career';\n\nlet anzsrcCodeGuidance = '5-7';\nlet fosCodeGuidance = '2-4';\nlet careerStageDescription = 'mid-career researcher with multi-domain expertise';\n\nif (careerStage === 'early-career' || careerStage.includes('early')) {\n  anzsrcCodeGuidance = '3-5';\n  fosCodeGuidance = '2-3';\n  careerStageDescription = 'early-career researcher with focused expertise';\n} else if (careerStage === 'senior' || careerStage.includes('senior') || careerStage === 'emeritus') {\n  anzsrcCodeGuidance = '7-10';\n  fosCodeGuidance = '3-5';\n  careerStageDescription = 'senior/established researcher with highly interdisciplinary portfolio';\n}\n\n// ============================================================\n// BUILD CLASSIFICATION PROMPT (v3.7.3 / instance_spec v2.2)\n// ============================================================\nconst userPrompt = `You are a research classification specialist. Your task is to classify a researcher's profile against the Australian and New Zealand Standard Research Classification (ANZSRC) Field of Research (FoR) codes.\n\n============================================================\nRESEARCHER PROFILE\n============================================================\n\nName: ${inputData.name || 'Unknown'}\nInstitution: ${inputData.institution || 'Unknown'}\nORCID: ${inputData.orcid || 'Not available'}\n\n------------------------------------------------------------\nRAW EVIDENCE (from source data - use this for justifications)\n------------------------------------------------------------\n\nBIOGRAPHY:\n${biography || 'Not available'}\n\nRESEARCH INTERESTS:\n${researchInterests.length > 0 ? researchInterests.join(', ') : 'Not specified'}\n\nPUBLICATIONS (${publications.length} total, showing top ${Math.min(publications.length, 15)}):\n${pubList || '  No publications available'}\n\nGRANTS (${grants.length} total):\n${grantList || '  No grants available'}\n\n------------------------------------------------------------\nENRICHED CONTEXT (from LLM analysis)\n------------------------------------------------------------\n\nResearch Domains: ${(enrichedContext.research_domains || inputData.research_domains || []).join(', ') || 'Not extracted'}\n\nCore Methodologies: ${(enrichedContext.methodologies || inputData.methodologies || []).join(', ') || 'Not extracted'}\n\nResearch Themes: ${(enrichedContext.themes || inputData.research_themes || []).join(', ') || 'Not extracted'}\n\nKeywords: ${(enrichedContext.keywords || []).join(', ') || 'Not extracted'}\n\n------------------------------------------------------------\nMETRICS\n------------------------------------------------------------\n\nH-index: ${inputData.h_index || 0}\nCareer Stage: ${careerStage} (${careerStageDescription})\n\n============================================================\nDUAL-STANDARD CLASSIFICATION TASK\n============================================================\n\nYou must classify this researcher against TWO taxonomies independently.\n\n------------------------------------------------------------\nSTANDARD A: ANZSRC Field of Research 2020 (Primary Classification)\n------------------------------------------------------------\n\nAssign ${anzsrcCodeGuidance} codes from the candidates below.\nThese are specific 6-digit codes representing detailed research fields.\n\nCANDIDATE CODES (from hierarchical retrieval):\n${anzsrcList || '  No candidates available'}\n\n------------------------------------------------------------\nSTANDARD B: OECD Fields of Science 2007 (Domain Context)\n------------------------------------------------------------\n\nAssign ${fosCodeGuidance} codes from the candidates below.\nThese are broader international domain classifications.\n\nCANDIDATE CODES:\n${fosList || '  No candidates available'}\n\n------------------------------------------------------------\nCLASSIFICATION RULES\n------------------------------------------------------------\n\n1. ADAPTIVE CODE COUNT based on career stage:\n   - Early-career / narrowly focused: 3-5 codes\n   - Mid-career / multi-domain: 5-7 codes\n   - Senior / highly interdisciplinary: 7-10 codes\n   \n   This researcher appears to be ${careerStage}, so assign ${anzsrcCodeGuidance} ANZSRC codes.\n\n2. EVIDENCE REQUIREMENT:\n   - Every code MUST cite SPECIFIC evidence from the profile\n   - Reference actual publication titles, grant names, or biography text\n   - Do NOT assign codes based on vague similarity\n\n3. CONFIDENCE THRESHOLD:\n   - Only assign codes where confidence >= 0.70\n   - Rank codes by relevance (primary expertise first)\n\n4. HIERARCHICAL CONSTRAINTS:\n   - Don't assign both parent and child codes (e.g., not both 31 and 3106)\n   - Prefer most specific (6-digit) codes over broad codes\n   - Avoid redundant classifications (highly overlapping sibling codes)\n\n------------------------------------------------------------\nRESPONSE FORMAT (JSON only)\n------------------------------------------------------------\n{\n  \"standard_a\": {\n    \"taxonomy\": \"ANZSRC_FoR_2020\",\n    \"classifications\": [\n      {\n        \"code\": \"310601\",\n        \"name\": \"Biocatalysis and enzyme technology\",\n        \"confidence\": 0.92,\n        \"justification\": \"12 publications on lipase engineering including 'Title of specific paper'; ARC grant 'Enzyme optimisation for industrial bioprocessing'\",\n        \"evidence\": [\"Lipase immobilisation research\", \"ARC DP210101234\"]\n      }\n    ]\n  },\n  \"standard_b\": {\n    \"taxonomy\": \"OECD_FOS_2007\",\n    \"classifications\": [\n      {\n        \"code\": \"1.6\",\n        \"name\": \"Biological Sciences\",\n        \"confidence\": 0.88,\n        \"justification\": \"Broader domain alignment with biotechnology focus evident across publication portfolio\"\n      }\n    ]\n  },\n  \"career_stage_assessed\": \"${careerStage}\",\n  \"classification_depth_rationale\": \"Explanation of why N codes were assigned based on career breadth\",\n  \"reasoning\": \"Overall summary of how Standard A and Standard B classifications collectively represent the researcher's expertise\"\n}\n\n------------------------------------------------------------\nCRITICAL RULES\n------------------------------------------------------------\n1. Respond ONLY with valid JSON - no markdown, no code blocks, no extra text\n2. Standard A codes MUST be from the ANZSRC candidates listed above\n3. Standard B codes MUST be from the OECD FOS candidates listed above\n4. Every justification must reference SPECIFIC evidence (publication titles, grant names)\n5. Do NOT under-classify senior researchers - a 30-year career spanning multiple domains should have 7-10 codes\n6. Do NOT over-classify early-career researchers - limited evidence should result in 3-5 focused codes`;\n\n// ============================================================\n// RETURN OUTPUT\n// ============================================================\nreturn [{\n  json: {\n    // Pass through researcher data\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    orcid: inputData.orcid,\n    institution: inputData.institution,\n    qdrant_point_id: inputData.qdrant_point_id,\n    model: 'anthropic/claude-opus-4.5',\n    \n    // Dense view for downstream nodes\n    dense_view_text: inputData.dense_view_text,\n    \n    // v3.7.3: Pass through the CORRECT raw_evidence from denseViewParsed\n    raw_evidence: rawEvidence,\n    enriched_context: enrichedContext,\n    \n    // Research profile\n    research_domains: inputData.research_domains,\n    methodologies: inputData.methodologies,\n    research_themes: inputData.research_themes,\n    h_index: inputData.h_index,\n    career_stage: careerStage,\n    \n    // Data quality (pass through)\n    data_quality: inputData.data_quality,\n    \n    // Candidates for reference\n    field_candidates: anzsrcCandidates,\n    field_candidate_count: anzsrcCandidates.length,\n    fos_candidates: fosCandidates,\n    fos_candidate_count: fosCandidates.length,\n    \n    // Hierarchical search metadata\n    matched_groups: inputData.matched_groups,\n    retrieval_sources: inputData.retrieval_sources,\n    reranking: inputData.reranking,\n    \n    // LLM prompt\n    user_prompt: userPrompt,\n    \n    // Guidance used (for tracking/audit)\n    classification_guidance: {\n      career_stage: careerStage,\n      career_stage_description: careerStageDescription,\n      anzsrc_code_range: anzsrcCodeGuidance,\n      fos_code_range: fosCodeGuidance\n    },\n    \n    // Retry tracking\n    llm_retry_count: inputData.llm_retry_count || 0,\n    \n    // v3.7.3: Debug info\n    _debug_publications_count: publications.length,\n    _debug_source: denseViewParsed.raw_evidence ? 'merge_embedding' : 'input_data'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2432,
        2256
      ],
      "id": "8957ec47-87b1-4767-95ec-670c6cfefbd6",
      "name": "Prepare Dual-Standard LLM Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "cohereApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.cohere_request_body) }}",
        "options": {}
      },
      "id": "29295b5c-231e-4707-926a-83b948873f09",
      "name": "Cohere Rerank",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1216,
        2256
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        },
        "cohereApi": {
          "id": "JyKbWvdds8nxsq1s",
          "name": "CohereApi Production Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Node: Prepare Cohere Request (FIXED)\nconst inputData = $input.first().json;\n\n// Build documents array using embedding_text for rich context\nconst documents = inputData.field_candidates.map(f => {\n  if (f.embedding_text) {\n    return f.embedding_text;\n  } else {\n    return `${f.code} - ${f.name}`;\n  }\n});\n\nconst richContextCount = inputData.field_candidates.filter(f => f.embedding_text).length;\nconsole.log(`Cohere request: ${documents.length} documents (${richContextCount} with rich context)`);\n\n// Build Cohere rerank request body\nconst cohereRequestBody = {\n  model: \"rerank-v3.5\",\n  query: inputData.dense_view_text,\n  documents: documents,\n  top_n: 25\n};\n\nreturn [{\n  json: {\n    // Pass through all researcher data explicitly\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    orcid: inputData.orcid,\n    institution: inputData.institution,\n    qdrant_point_id: inputData.qdrant_point_id,\n    research_domains: inputData.research_domains,\n    methodologies: inputData.methodologies,\n    research_themes: inputData.research_themes,\n    h_index: inputData.h_index,\n    career_stage: inputData.career_stage,\n    dense_view_text: inputData.dense_view_text,\n    embedding_vector: inputData.embedding_vector,\n    \n    // Field candidates\n    field_candidates: inputData.field_candidates,\n    field_codes: inputData.field_codes,\n    vector_candidate_count: inputData.vector_candidate_count,\n    \n    // Cohere request body\n    cohere_request_body: cohereRequestBody\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        2256
      ],
      "id": "9c1564f9-a7d2-4452-8b21-43bae31d0434",
      "name": "Prepare Cohere Request"
    },
    {
      "parameters": {
        "jsCode": "// Parse Cohere Rerank Results\nconst cohereResponse = $input.first().json;\nconst originalData = $('Parse Vector Search Results').item.json;\n\nconst fieldCandidates = originalData.field_candidates;\nconst rerankedResults = cohereResponse.results || [];\n\n// Map reranked indices back to original candidates\nconst rerankedCandidates = rerankedResults.map(result => ({\n  ...fieldCandidates[result.index],\n  rerank_score: result.relevance_score\n}));\n\nreturn [{\n  json: {\n    ...originalData,\n    field_candidates: rerankedCandidates,\n    field_candidate_count: rerankedCandidates.length,\n    reranking: {\n      applied: true,\n      model: 'rerank-v3.5',\n      original_count: fieldCandidates.length,\n      reranked_count: rerankedCandidates.length\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        2256
      ],
      "id": "f62914c3-abd8-4dac-bf19-6a17bc7da768",
      "name": "Parse Cohere Rerank Results"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/standards_anzsrc1_for_2020/points/query",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.qdrant_field_request) }}",
        "options": {}
      },
      "id": "90c97c46-1c3d-4753-9b86-951c00d0bdbc",
      "name": "Vector Search FIELDS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        448,
        2256
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        688,
        1584
      ],
      "id": "4338ee3d-fae0-4d06-a53f-71f190e617de",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Handle Sparse Data Check\n// Version: v3.8.3 - ALWAYS CLASSIFY, let OBJECT-4 route\n// Per Definition Card: OBJECT-3 classifies all, OBJECT-4 routes\n// ============================================================\n\nconst inputData = $input.first().json;\n\n// Get counts from TOP LEVEL\nconst biography = inputData.biography || '';\nconst researchInterests = inputData.research_interests || [];\nconst researchDomains = inputData.research_domains || [];\nconst researchThemes = inputData.research_themes || [];\nconst methodologies = inputData.methodologies || [];\nconst publicationCount = inputData.publication_count || 0;\nconst hIndex = inputData.h_index || 0;\n\n// Calculate metrics\nconst biographyLength = biography.length;\nconst researchInterestCount = researchInterests.length;\nconst domainCount = researchDomains.length;\nconst themeCount = researchThemes.length;\n\n// Determine evidence quality\nconst hasPublications = publicationCount >= 3;\nconst hasBiography = biographyLength >= 100;\nconst hasResearchInterests = researchInterestCount >= 3;\nconst hasDomains = domainCount >= 1;\nconst hasThemes = themeCount >= 1;\n\nconst hasSufficientEvidence = hasPublications || hasBiography || hasResearchInterests;\nconst hasEnrichedContext = hasDomains || hasThemes;\nconst isSufficient = hasSufficientEvidence && hasEnrichedContext;\nconst isSparse = !isSufficient;\n\n// Build data quality object\nconst dataQuality = {\n  publication_count: publicationCount,\n  biography_length: biographyLength,\n  research_interest_count: researchInterestCount,\n  research_domains_count: domainCount,\n  research_themes_count: themeCount,\n  h_index: hIndex,\n  \n  has_publications: hasPublications,\n  has_biography: hasBiography,\n  has_research_interests: hasResearchInterests,\n  has_domains: hasDomains,\n  has_themes: hasThemes,\n  \n  has_sufficient_evidence: hasSufficientEvidence,\n  has_enriched_context: hasEnrichedContext,\n  sufficient: isSufficient,\n  is_sparse: isSparse,\n  \n  missing_fields: [],\n  confidence_penalty: 0\n};\n\n// Track missing fields\nif (!hasPublications) dataQuality.missing_fields.push('publications');\nif (!hasBiography) dataQuality.missing_fields.push('biography');\nif (!hasResearchInterests) dataQuality.missing_fields.push('research_interests');\nif (!hasDomains) dataQuality.missing_fields.push('domains');\nif (!hasThemes) dataQuality.missing_fields.push('themes');\n\n// v3.8.3: Apply confidence penalty for sparse data (OBJECT-4 will route)\nif (isSparse) {\n  dataQuality.confidence_penalty = 0.25; // -25% for sparse data\n  dataQuality.has_issue = true;\n} else if (dataQuality.missing_fields.length > 0) {\n  dataQuality.confidence_penalty = 0.10; // -10% for partial data\n  dataQuality.has_issue = true;\n}\n\n// Logging\nconsole.log(`\\n============================================================`);\nconsole.log(`üìä DATA QUALITY CHECK: ${inputData.name}`);\nconsole.log(`============================================================`);\nconsole.log(`   Publications:        ${publicationCount} ${hasPublications ? '‚úÖ' : '‚ö†Ô∏è'}`);\nconsole.log(`   Biography:           ${biographyLength} chars ${hasBiography ? '‚úÖ' : '‚ö†Ô∏è'}`);\nconsole.log(`   Research Interests:  ${researchInterestCount} ${hasResearchInterests ? '‚úÖ' : '‚ö†Ô∏è'}`);\nconsole.log(`   Research Domains:    ${domainCount} ${hasDomains ? '‚úÖ' : '‚ö†Ô∏è'}`);\nconsole.log(`   Themes:              ${themeCount} ${hasThemes ? '‚úÖ' : '‚ö†Ô∏è'}`);\nconsole.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);\nconsole.log(`   Data Status:         ${isSparse ? 'SPARSE ‚ö†Ô∏è' : 'SUFFICIENT ‚úÖ'}`);\nconsole.log(`   Confidence Penalty:  -${dataQuality.confidence_penalty * 100}%`);\nconsole.log(`   ACTION:              PROCEED TO CLASSIFICATION ‚úÖ`);\nconsole.log(`   (OBJECT-4 will route based on final confidence)`);\nconsole.log(`============================================================\\n`);\n\n// ============================================================\n// v3.8.3: ALWAYS proceed to classification\n// OBJECT-4 will route based on final confidence score\n// ============================================================\nreturn [{\n  json: {\n    ...inputData,\n    data_quality: dataQuality,\n    classification_skipped: false,\n    routing_decision: 'PROCEED_TO_CLASSIFICATION'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        1968
      ],
      "id": "53e48356-fcc5-4e57-b227-92c4e286ba1c",
      "name": "Check Data Quality"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "eaf1b00f-6064-48cb-862c-48270ad1671a",
              "leftValue": "={{ $json.needs_retry }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -368,
        2576
      ],
      "id": "e2396077-e02c-49d6-abbf-d293feb47204",
      "name": "Check Parse Success"
    },
    {
      "parameters": {
        "jsCode": "// Update FATObject status to classification_failed in Neo4j\nconst inputData = $input.first().json;\n\nreturn [{\n  json: {\n    ...inputData,\n    neo4j_failure_update: {\n      statement: `\n        MATCH (fat:FATObject {asset_id: $asset_id})\n        SET fat.status = 'classification_failed',\n            fat.classification_error = $error_message,\n            fat.classification_failed_at = datetime(),\n            fat.llm_retry_count = $retry_count\n        RETURN fat.asset_id, fat.status, fat.classification_error\n      `,\n      parameters: {\n        asset_id: inputData.asset_id,\n        error_message: inputData.failure_reason || inputData.parse_error || 'Unknown error',\n        retry_count: inputData.llm_retry_count || 0\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        2960
      ],
      "id": "3323f183-5e1e-494e-915b-956fe4b70f64",
      "name": "Prepare Failure Update (Neo4j)"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_failure_update }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -272,
        2960
      ],
      "id": "d4c44955-c8ba-4da8-bfd8-6b20473201f6",
      "name": "Execute Status Update to (Sparse Data)1",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "eaf1b00f-6064-48cb-862c-48270ad1671a",
              "leftValue": "={{ $json.classification_failed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -80,
        2592
      ],
      "id": "ca072a78-2b20-4c36-9c35-ae448d6bf0c0",
      "name": "Classification Failed"
    },
    {
      "parameters": {
        "jsCode": "// Node: Prepare Vector Search GROUPS (Phase 2a)\n// v3.7: Hierarchical search - groups first, then fields within matched groups\n\nconst inputData = $input.first().json;\n\n// Validate embedding vector\nif (!inputData.embedding_vector || inputData.embedding_vector.length !== 3072) {\n  throw new Error(`Invalid embedding vector. Expected 3072 dimensions, got ${inputData.embedding_vector?.length || 0}`);\n}\n\n// Qdrant request for GROUP-level search (4-digit codes)\nconst qdrantGroupRequest = {\n  query: inputData.embedding_vector,\n  filter: {\n    must: [{\n      key: \"level\",\n      match: { value: \"group\" }\n    }]\n  },\n  limit: 35,\n  with_payload: true,\n  with_vector: false\n};\n\nreturn [{\n  json: {\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    orcid: inputData.orcid,\n    institution: inputData.institution,\n    qdrant_point_id: inputData.qdrant_point_id,\n    dense_view_text: inputData.dense_view_text,\n    raw_evidence: inputData.raw_evidence,\n    enriched_context: inputData.enriched_context,\n    career_stage: inputData.career_stage,\n    research_domains: inputData.research_domains,\n    methodologies: inputData.methodologies,\n    research_themes: inputData.research_themes,\n    h_index: inputData.h_index,\n    data_quality: inputData.data_quality,\n    embedding_vector: inputData.embedding_vector,\n    qdrant_group_request: qdrantGroupRequest\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        2256
      ],
      "id": "982ae28a-94f7-4838-b908-7ef5029e69d8",
      "name": "Prepare Vector Search GROUPS"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/standards_anzsrc1_for_2020/points/query",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.qdrant_group_request) }}",
        "options": {}
      },
      "id": "cbddba33-be85-42f0-a1f3-2259105978de",
      "name": "Vector Search GROUPS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -432,
        2256
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Group Vector Search Results & Prepare Cohere Rerank\n// Phase 2a Step 3: Rerank top 35 groups to top 20\n\nconst qdrantResponse = $input.first().json;\nconst originalData = $('Prepare Vector Search GROUPS').item.json;\n\nconst responseData = Array.isArray(qdrantResponse) ? qdrantResponse[0] : qdrantResponse;\nconst points = responseData.result?.points || [];\n\nif (points.length === 0) {\n  console.log('‚ö†Ô∏è No groups found - falling back to flat field search');\n  \n  // Fallback: direct field search without group filtering\n  const fallbackFieldRequest = {\n    query: originalData.embedding_vector,\n    filter: {\n      must: [{\n        key: \"level\",\n        match: { value: \"field\" }\n      }]\n    },\n    limit: 75,\n    with_payload: true,\n    with_vector: false\n  };\n  \n  return [{\n    json: {\n      ...originalData,\n      group_candidates: [],\n      matched_group_numbers: [],\n      use_hierarchical_search: false,\n      fallback_reason: 'No group matches found',\n      qdrant_field_request: fallbackFieldRequest\n    }\n  }];\n}\n\n// Extract group candidates\nconst groupCandidates = points.map(point => ({\n  code: point.payload.code,\n  name: point.payload.name,\n  score: point.score,\n  embedding_text: point.payload.embedding_text || `${point.payload.code} - ${point.payload.name}`\n}));\n\nconsole.log(`‚úÖ Group Vector Search: Found ${groupCandidates.length} groups`);\nconsole.log(`   Top 5: ${groupCandidates.slice(0, 5).map(g => `${g.code} (${g.score.toFixed(3)})`).join(', ')}`);\n\n// Prepare Cohere rerank to get top 20 groups\nconst cohereGroupRequest = {\n  model: \"rerank-v3.5\",\n  query: originalData.dense_view_text,\n  documents: groupCandidates.map(g => g.embedding_text),\n  top_n: 20\n};\n\nreturn [{\n  json: {\n    ...originalData,\n    group_candidates: groupCandidates,\n    cohere_group_request: cohereGroupRequest,\n    use_hierarchical_search: true\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        2256
      ],
      "id": "2cbe8d8a-84d7-41ea-9cc9-2a4dcd9db17e",
      "name": "Parse Group Results & Prepare Cohere"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "cohereApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.cohere_group_request) }}",
        "options": {}
      },
      "id": "c45de64b-95f0-48a6-b5ba-6e91f3c6c865",
      "name": "Cohere Rerank Groups",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        32,
        2256
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        },
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        },
        "cohereApi": {
          "id": "JyKbWvdds8nxsq1s",
          "name": "CohereApi Production Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Node: Extract Matched Groups\n// Version: v3.7.0\n// Purpose: Extract top 20 reranked groups and prepare field search with group filter\n// Phase 2a complete -> Phase 2b setup\n// ============================================================\n\nconst cohereResponse = $input.first().json;\nconst originalData = $('Parse Group Results & Prepare Cohere').item.json;\n\n// ============================================================\n// FALLBACK: Skip if not using hierarchical search\n// ============================================================\nif (!originalData.use_hierarchical_search) {\n  console.log('‚ö†Ô∏è Hierarchical search disabled, using fallback');\n  return [{ json: originalData }];\n}\n\n// ============================================================\n// PARSE COHERE RERANK RESULTS\n// ============================================================\nconst results = cohereResponse.results || [];\nconst groupCandidates = originalData.group_candidates || [];\n\nif (results.length === 0) {\n  console.log('‚ö†Ô∏è No rerank results, falling back to all groups');\n  return [{ json: originalData }];\n}\n\n// ============================================================\n// MAP COHERE INDICES BACK TO GROUP CODES\n// CRITICAL: Ensure codes are STRINGS for Qdrant filter\n// ============================================================\nconst matchedGroups = results.map(r => {\n  const group = groupCandidates[r.index];\n  \n  if (!group) {\n    console.log(`‚ö†Ô∏è No group found at index ${r.index}`);\n    return null;\n  }\n  \n  return {\n    code: String(group.code),           // ‚úÖ ENSURE STRING\n    name: group.name || 'Unknown',\n    vector_score: group.score || 0,\n    rerank_score: r.relevance_score || 0\n  };\n}).filter(g => g !== null);\n\n// ============================================================\n// EXTRACT GROUP NUMBERS (4-digit codes as STRINGS)\n// ============================================================\nconst matchedGroupNumbers = matchedGroups.map(g => String(g.code));\n\nconsole.log(`‚úÖ Reranked to ${matchedGroups.length} groups`);\nconsole.log(`   Top 5 groups: ${matchedGroupNumbers.slice(0, 5).join(', ')}`);\nconsole.log(`   Type check: ${typeof matchedGroupNumbers[0]}`);\n\n// ============================================================\n// BUILD QDRANT FIELD REQUEST WITH GROUP FILTER (Phase 2b)\n// ============================================================\nconst qdrantFieldRequest = {\n  query: originalData.embedding_vector,\n  filter: {\n    must: [\n      {\n        key: \"level\",\n        match: { value: \"field\" }\n      },\n      {\n        key: \"group_code\",\n        match: { any: matchedGroupNumbers }  // Strings for keyword index\n      }\n    ]\n  },\n  limit: 50,\n  with_payload: true,\n  with_vector: false\n};\n\n// ============================================================\n// OUTPUT: Pass through all data plus matched groups\n// ============================================================\nreturn [{\n  json: {\n    // Pass through original data\n    ...originalData,\n    \n    // Matched groups from reranking\n    matched_groups: matchedGroups,\n    matched_group_numbers: matchedGroupNumbers,\n    group_count: matchedGroups.length,\n    \n    // Qdrant request for field search\n    qdrant_field_request: qdrantFieldRequest,\n    \n    // Retrieval metadata\n    retrieval_sources: {\n      phase_2a_groups: matchedGroups.length,\n      phase_2a_method: 'vector_search + cohere_rerank',\n      phase_2a_top_group: matchedGroups[0]?.code || 'none'\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        2256
      ],
      "id": "b4358014-b93a-4df2-8f9c-a4d497f98a5f",
      "name": "Extract Matched Groups"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Node: Parse Vector Search Results (FIELD Search)\n// Version: v3.7.0\n// Input: Qdrant vector search response for FIELDS\n// Output: Structured field candidates with embedding_text for LLM\n// ============================================================\n\nconst qdrantResponse = $input.first().json;\n\n// ============================================================\n// GET ORIGINAL DATA - Use correct node name!\n// ============================================================\nconst originalData = $('Extract Matched Groups').item.json;\n\n// Handle response structure\nconst responseData = Array.isArray(qdrantResponse) ? qdrantResponse[0] : qdrantResponse;\nconst points = responseData.result?.points || responseData.points || [];\n\nif (points.length === 0) {\n  console.log('‚ö†Ô∏è No field candidates found, check Qdrant query');\n  throw new Error(`No candidate standards found for asset_id: ${originalData.asset_id}`);\n}\n\n// ============================================================\n// EXTRACT FIELD CANDIDATES WITH SCORES AND EMBEDDING_TEXT\n// ============================================================\nconst fieldCandidates = points.map(point => ({\n  code: String(point.payload.code),\n  name: point.payload.name,\n  level: point.payload.level,\n  division_code: point.payload.division_code || String(point.payload.code).substring(0, 2),\n  group_code: point.payload.group_code || String(point.payload.code).substring(0, 4),\n  embedding_text: point.payload.embedding_text || null,\n  score: point.score\n}));\n\n// Get unique field codes\nconst fieldCodes = [...new Set(fieldCandidates.map(c => c.code))];\n\n// Log candidate pool\nconsole.log(`‚úÖ Field search returned ${points.length} candidates`);\nconsole.log(`   Fields with embedding_text: ${fieldCandidates.filter(f => f.embedding_text).length}`);\nconsole.log(`   Top 3 fields: ${fieldCandidates.slice(0, 3).map(f => f.code).join(', ')}`);\n\n// ============================================================\n// OUTPUT: Merge original data with field candidates\n// ============================================================\nreturn [{\n  json: {\n    // Pass through researcher data\n    asset_id: originalData.asset_id,\n    name: originalData.name,\n    orcid: originalData.orcid,\n    institution: originalData.institution,\n    qdrant_point_id: originalData.qdrant_point_id,\n    research_domains: originalData.research_domains || [],\n    methodologies: originalData.methodologies || [],\n    research_themes: originalData.research_themes || [],\n    h_index: originalData.h_index || 0,\n    career_stage: originalData.career_stage || 'unknown',\n    \n    // v3.7: raw_evidence and enriched_context\n    raw_evidence: originalData.raw_evidence || {},\n    enriched_context: originalData.enriched_context || {},\n    data_quality: originalData.data_quality || {},\n    \n    // Dense view text for LLM prompt\n    dense_view_text: originalData.dense_view_text || '',\n    \n    // Embedding for FOS search later\n    embedding_vector: originalData.embedding_vector,\n    \n    // FIELD candidate data (includes embedding_text)\n    field_candidates: fieldCandidates,\n    field_codes: fieldCodes,\n    vector_candidate_count: points.length,\n    \n    // Hierarchical search metadata\n    matched_groups: originalData.matched_groups || [],\n    matched_group_numbers: originalData.matched_group_numbers || [],\n    retrieval_sources: originalData.retrieval_sources || {}\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        2256
      ],
      "id": "bfa2bc0f-42b5-45c7-9358-538c9635f32b",
      "name": "Parse Vector Search Results"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Prepare Classification Signals for Neo4j (FIXED v3)\n// Version: v3.7.2\n// Fix: Uses MERGE to prevent duplicate signals\n// ============================================================\n\nconst inputData = $('Prepare Qdrant Payload').item.json;\nconst timestamp = new Date().toISOString();\nconst assetId = inputData.asset_id;\n\n// Build signals array\nconst signals = [];\n\n// ============================================================\n// 1. classification_completed (ALWAYS emitted)\n// ============================================================\nsignals.push({\n  signal_type: \"classification_completed\",\n  category: \"AssessmentSignal\",\n  target_entity: assetId,\n  timestamp: timestamp,\n  value: inputData.final_confidence,\n  reason: \"Classification completed successfully\",\n  metadata: JSON.stringify({\n    primary_code: inputData.classifications[0]?.code || null,\n    primary_label: inputData.classifications[0]?.name || null,\n    secondary_codes: inputData.classifications.slice(1).map(c => c.code),\n    code_count: inputData.classification_count,\n    standard_b_count: inputData.standard_b_count || 0,\n    raw_confidence: inputData.confidence_breakdown?.base_mean || null,\n    crosswalk_modifier: inputData.confidence_breakdown?.crosswalk_modifier || 0,\n    model_version: inputData.model || \"open-oss-120b\"\n  }),\n  workflow_id: \"OBJECT-3\",\n  workflow_version: \"v3.7\"\n});\n\n// ============================================================\n// 2. confidence_assessed (ALWAYS emitted)\n// ============================================================\nsignals.push({\n  signal_type: \"confidence_assessed\",\n  category: \"MeasurementSignal\",\n  target_entity: assetId,\n  timestamp: timestamp,\n  value: inputData.final_confidence,\n  reason: \"Confidence score calculated with modifiers\",\n  metadata: JSON.stringify({\n    raw_confidence: inputData.confidence_breakdown?.base_mean || null,\n    cf1_penalty: inputData.confidence_breakdown?.cf1_penalty || 0,\n    crosswalk_modifier: inputData.confidence_breakdown?.crosswalk_modifier || 0,\n    cre_penalty: inputData.confidence_breakdown?.cre_penalty || 0,\n    data_quality_penalty: inputData.confidence_breakdown?.data_quality_penalty || 0,\n    net_adjustment: inputData.confidence_breakdown?.net_adjustment || 0\n  }),\n  workflow_id: \"OBJECT-3\",\n  workflow_version: \"v3.7\"\n});\n\n// ============================================================\n// 3. data_quality_warning (CONDITIONAL)\n// ============================================================\nlet dataQuality = null;\ntry {\n  dataQuality = $('Handle Sparse Data').item.json.data_quality;\n} catch (e) {\n  dataQuality = inputData.data_quality || null;\n}\n\nif (dataQuality?.has_issue) {\n  signals.push({\n    signal_type: \"data_quality_warning\",\n    category: \"SystemSignal\",\n    target_entity: assetId,\n    timestamp: timestamp,\n    value: (dataQuality.confidence_penalty || 0) * -1,\n    reason: \"Dense view missing required fields for classification grounding\",\n    metadata: JSON.stringify({\n      missing_fields: dataQuality.missing_fields || [],\n      confidence_penalty_applied: dataQuality.confidence_penalty || 0,\n      flagged_for_review: true\n    }),\n    workflow_id: \"OBJECT-3\",\n    workflow_version: \"v3.7\"\n  });\n}\n\n// ============================================================\n// 4. threshold_breach (CONDITIONAL)\n// ============================================================\nconst AUTO_APPROVE_THRESHOLD = 0.85;\nconst FAIL_THRESHOLD = 0.60;\n\nif (inputData.final_confidence < AUTO_APPROVE_THRESHOLD) {\n  const routedTo = inputData.final_confidence >= FAIL_THRESHOLD \n    ? \"validation_queue\" \n    : \"reject\";\n  \n  signals.push({\n    signal_type: \"threshold_breach\",\n    category: \"AssessmentSignal\",\n    target_entity: assetId,\n    timestamp: timestamp,\n    value: inputData.final_confidence,\n    reason: \"Confidence score below auto-approval threshold\",\n    metadata: JSON.stringify({\n      threshold: AUTO_APPROVE_THRESHOLD,\n      actual_score: inputData.final_confidence,\n      gap: Math.round((inputData.final_confidence - AUTO_APPROVE_THRESHOLD) * 10000) / 10000,\n      routed_to: routedTo\n    }),\n    workflow_id: \"OBJECT-3\",\n    workflow_version: \"v3.7\"\n  });\n}\n\n// ============================================================\n// BUILD CYPHER USING MERGE (Prevents Duplicates)\n// ============================================================\nconst signalNeo4jPayload = {\n  statement: `\n    UNWIND $signals AS sig\n    \n    MATCH (e {asset_id: sig.target_entity})\n    \n    MERGE (s:Signal {\n      target_entity: sig.target_entity,\n      signal_type: sig.signal_type,\n      workflow_id: sig.workflow_id\n    })\n    ON CREATE SET\n      s.signal_id = sig.target_entity + ':' + sig.signal_type + ':' + sig.workflow_id,\n      s.category = sig.category,\n      s.timestamp = datetime(sig.timestamp),\n      s.value = sig.value,\n      s.reason = sig.reason,\n      s.metadata = sig.metadata,\n      s.workflow_version = sig.workflow_version\n    ON MATCH SET\n      s.timestamp = datetime(sig.timestamp),\n      s.value = sig.value,\n      s.reason = sig.reason,\n      s.metadata = sig.metadata,\n      s.workflow_version = sig.workflow_version\n    \n    MERGE (e)-[:HAS_SIGNAL]->(s)\n    \n    RETURN count(s) AS signals_merged\n  `,\n  parameters: {\n    signals: signals\n  }\n};\n\n// ============================================================\n// LOG SUMMARY\n// ============================================================\nconsole.log(`\\n============================================================`);\nconsole.log(`üì° SIGNAL EMISSION: ${inputData.name}`);\nconsole.log(`============================================================`);\nsignals.forEach(s => {\n  console.log(`   ${s.category === 'SystemSignal' ? '‚ö†Ô∏è' : '‚úÖ'} ${s.signal_type}`);\n});\nconsole.log(`   Total signals: ${signals.length}`);\nconsole.log(`============================================================\\n`);\n\n// ============================================================\n// RETURN OUTPUT\n// ============================================================\nreturn [{\n  json: {\n    ...inputData,\n    signals_emitted: signals,\n    signal_count: signals.length,\n    signal_neo4j_payload: signalNeo4jPayload\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        2864
      ],
      "id": "9aaac348-6ea1-49ea-bbbb-e61cbbcd413f",
      "name": "Prepare Classification Signals"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://34204fed.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.signal_neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1536,
        2864
      ],
      "id": "19e5c014-6d74-402f-ab86-19bfe8b90d05",
      "name": "Write Signals to Neo4j",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// OBJECT-3 Classification Report Generator\n// Version: v3.8.3 - FIXED: Code count, CRE display, Flag details, FOS evidence\n// Schema: Richard Williams style template + Tier badges + Sources + Full CRE\n// ============================================================\n\nconst results = $input.all();\nconsole.log(`=== GENERATING ${results.length} CLASSIFICATION REPORTS (v3.8.3) ===`);\n\n// ============================================================\n// HELPER FUNCTIONS\n// ============================================================\n\nfunction getInitials(name) {\n  if (!name) return '??';\n  return name.split(' ')\n    .map(part => part.charAt(0).toUpperCase())\n    .slice(0, 2)\n    .join('');\n}\n\nfunction formatConfidence(conf) {\n  if (conf === null || conf === undefined) return 'N/A';\n  return Math.round(conf * 100);\n}\n\nfunction getRoutingBadgeClass(recommendation) {\n  switch (recommendation) {\n    case 'AUTO_APPROVE': return 'success';\n    case 'HUMAN_REVIEW': return 'aligned';\n    case 'REJECT': return 'fail';\n    default: return '';\n  }\n}\n\nfunction formatRoutingLabel(recommendation) {\n  switch (recommendation) {\n    case 'AUTO_APPROVE': return 'Auto-Approve';\n    case 'HUMAN_REVIEW': return 'Human Review';\n    case 'REJECT': return 'Reject';\n    default: return recommendation;\n  }\n}\n\n// v3.8: Get tier badge HTML\nfunction getTierBadge(tier, rank) {\n  if (tier === 'primary') {\n    return `<span class=\"tier-badge tier-primary\">#${rank} PRIMARY</span>`;\n  } else if (tier === 'secondary') {\n    return `<span class=\"tier-badge tier-secondary\">#${rank} SECONDARY</span>`;\n  }\n  return '';\n}\n\n// v3.8: Get tier card class\nfunction getTierCardClass(tier) {\n  if (tier === 'primary') return 'tier-primary-card';\n  if (tier === 'secondary') return 'tier-secondary-card';\n  return '';\n}\n\n// v3.8.2: Source icon class helper\nfunction getSourceClass(source) {\n  const lowerSource = source.toLowerCase();\n  if (lowerSource.includes('orcid')) return 'orcid';\n  if (lowerSource.includes('scopus')) return 'scopus';\n  if (lowerSource.includes('scholar')) return 'scholar';\n  if (lowerSource.includes('university') || lowerSource.includes('profile')) return 'university_web_profile';\n  if (lowerSource.includes('patent')) return 'patents';\n  if (lowerSource.includes('grant')) return 'grants';\n  return '';\n}\n\n// v3.8.2: Format source name for display\nfunction formatSourceName(source) {\n  return source.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n}\n\n// ============================================================\n// MAIN HTML GENERATOR\n// ============================================================\n\nfunction generateClassificationHTML(data) {\n  const assetId = data.asset_id || 'unknown';\n  const name = data.name || 'Unknown Researcher';\n  const initials = getInitials(name);\n  const institution = data.institution || 'Institution';\n  \n  // v3.8.2: Data Sources\n  const dataSources = data.data_sources || {};\n  const sourcesScrapedList = dataSources.scraped_from || [];\n  \n  // Standard A (ANZSRC)\n  const standardA = data.standard_a || {};\n  const anzsrcClassifications = standardA.classifications || [];\n  const anzsrcCount = standardA.count || anzsrcClassifications.length;\n  \n  // v3.8: Count tiers\n  const primaryCodes = anzsrcClassifications.filter(c => c.tier === 'primary');\n  const secondaryCodes = anzsrcClassifications.filter(c => c.tier === 'secondary');\n  const primaryCount = primaryCodes.length;\n  const secondaryCount = secondaryCodes.length;\n  \n  // Standard B (OECD FOS)\n  const standardB = data.standard_b || {};\n  const oecdClassifications = standardB.classifications || [];\n  const oecdCount = standardB.count || oecdClassifications.length;\n  \n  // Assessment\n  const assessment = data.assessment || {};\n  const finalConfidence = assessment.final_confidence || 0;\n  const crosswalk = assessment.crosswalk || {};\n  const cf1 = assessment.anzsrc_hierarchy || {};\n  \n  // v3.8.3 FIX: Extract CRE assessment data\n  const cre = assessment.cre || {};\n  \n  // v3.8.3 FIX: Extract flag details arrays\n  const cf1FlagsDetail = cf1.flags_detail || [];\n  const cf1ViolationsDetail = cf1.violations_detail || [];\n  \n  // Routing\n  const routing = data.routing || {};\n  const routingRecommendation = routing.recommendation || 'HUMAN_REVIEW';\n  \n  // Storage\n  const storage = data.storage || {};\n  const neo4jRelationships = (storage.neo4j?.standard_a_relationships || 0) + \n                             (storage.neo4j?.standard_b_relationships || 0);\n  const postgresLogId = storage.postgresql?.record_id || 'N/A';\n  \n  // Metadata\n  const metadata = data.metadata || {};\n  const classifiedAt = metadata.classified_at || new Date().toISOString();\n  const classifiedBy = metadata.classified_by || 'object3_classifier_v3.8.3';\n  const model = metadata.model || 'anthropic/claude-opus-4.5';\n  const jobId = `clf_${assetId.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;\n  \n  const reasoning = data.reasoning || 'Classification reasoning not available.';\n  \n  // v3.8.2: Build Data Sources HTML\n  const sourcesHTML = sourcesScrapedList.length > 0 ? `\n    <div class=\"sources-section\">\n        <div class=\"sources-title\">Data Sources (${sourcesScrapedList.length} sources)</div>\n        <div class=\"sources-grid\">\n            ${sourcesScrapedList.map(source => `\n                <div class=\"source-badge ${getSourceClass(source)}\">\n                    ${formatSourceName(source)}\n                </div>\n            `).join('')}\n        </div>\n    </div>\n  ` : '';\n  \n  // v3.8.3 FIX: Build CF1 Flag Details HTML\n  const cf1FlagsHTML = cf1FlagsDetail.length > 0 ? `\n    <div class=\"flags-detail\">\n        <div class=\"flags-label\">Flag Details</div>\n        ${cf1FlagsDetail.map(f => `\n            <div class=\"flag-item\">\n                <span class=\"flag-rule\">${f.rule || 'Flag'}</span>: ${f.message || 'No details'}\n                ${f.code ? `<span class=\"flag-code\">Code: ${f.code}</span>` : ''}\n            </div>\n        `).join('')}\n    </div>\n  ` : '';\n  \n  const html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Classification Report ‚Äî ${name}</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=IBM+Plex+Sans:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap\" rel=\"stylesheet\">\n    <style>\n        :root {\n            --slate-950: #0f172a; --slate-900: #1e293b; --slate-800: #334155;\n            --slate-700: #475569; --slate-600: #64748b; --slate-500: #94a3b8;\n            --slate-400: #cbd5e1; --slate-300: #e2e8f0; --slate-200: #f1f5f9;\n            --slate-100: #f8fafc; --slate-50: #f8fafc;\n            --emerald-500: #10b981; --emerald-400: #34d399; --emerald-600: #059669;\n            --amber-500: #f59e0b; --amber-600: #d97706; --rose-500: #f43f5e;\n            --violet-500: #8b5cf6; --cyan-500: #06b6d4; --blue-500: #3b82f6;\n            --indigo-500: #6366f1; --teal-500: #14b8a6;\n            --gold-500: #eab308; --gold-600: #ca8a04;\n            --silver-500: #6b7280; --silver-400: #9ca3af;\n        }\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        body { font-family: 'IBM Plex Sans', sans-serif; background: linear-gradient(135deg, var(--slate-100) 0%, #e8ecf3 50%, var(--slate-200) 100%); min-height: 100vh; color: var(--slate-800); line-height: 1.6; }\n        .noise-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.03; background-image: url(\"data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E\"); z-index: 1000; }\n        .container { max-width: 1200px; margin: 0 auto; padding: 60px 40px; }\n        .report-header { margin-bottom: 60px; }\n        .report-meta { display: flex; align-items: center; gap: 16px; margin-bottom: 24px; }\n        .report-badge { background: var(--slate-900); color: var(--slate-100); padding: 6px 14px; border-radius: 4px; font-size: 11px; font-weight: 600; letter-spacing: 1.5px; text-transform: uppercase; }\n        .report-badge.dual { background: linear-gradient(135deg, var(--violet-500), var(--indigo-500)); }\n        .report-id { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--slate-500); }\n        .report-title { font-family: 'DM Serif Display', serif; font-size: 52px; font-weight: 400; color: var(--slate-900); line-height: 1.1; margin-bottom: 16px; }\n        .report-subtitle { font-size: 18px; color: var(--slate-600); font-weight: 300; }\n        .report-subtitle strong { font-weight: 500; color: var(--slate-700); }\n        .stats-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 20px; margin-bottom: 50px; }\n        .stat-card { background: white; border-radius: 16px; padding: 24px; position: relative; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04); }\n        .stat-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 4px; }\n        .stat-card.confidence::before { background: linear-gradient(90deg, var(--emerald-500), var(--emerald-400)); }\n        .stat-card.codes-a::before { background: linear-gradient(90deg, var(--violet-500), #a78bfa); }\n        .stat-card.codes-b::before { background: linear-gradient(90deg, var(--teal-500), #2dd4bf); }\n        .stat-card.crosswalk::before { background: linear-gradient(90deg, var(--emerald-500), var(--emerald-400)); }\n        .stat-card.routing::before { background: linear-gradient(90deg, var(--blue-500), #60a5fa); }\n        .stat-card.tier-primary::before { background: linear-gradient(90deg, var(--gold-500), #fcd34d); }\n        .stat-card.tier-secondary::before { background: linear-gradient(90deg, var(--silver-500), var(--silver-400)); }\n        .stat-label { font-size: 10px; font-weight: 600; letter-spacing: 1.2px; text-transform: uppercase; color: var(--slate-500); margin-bottom: 10px; }\n        .stat-value { font-family: 'DM Serif Display', serif; font-size: 32px; color: var(--slate-900); }\n        .stat-value.confidence { color: var(--emerald-600); }\n        .stat-value.amber { color: var(--amber-600); }\n        .stat-value.gold { color: var(--gold-600); }\n        .stat-value.silver { color: var(--silver-500); }\n        .stat-suffix { font-family: 'IBM Plex Sans', sans-serif; font-size: 14px; font-weight: 500; color: var(--slate-500); }\n        .stat-badge { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 8px; font-size: 12px; font-weight: 600; }\n        .stat-badge.success { background: rgba(16, 185, 129, 0.1); color: var(--emerald-600); }\n        .stat-badge.success::before { content: '‚úì'; font-weight: bold; }\n        .stat-badge.aligned { background: rgba(245, 158, 11, 0.1); color: var(--amber-600); }\n        .stat-badge.fail { background: rgba(244, 63, 94, 0.1); color: var(--rose-500); }\n        .stat-sub { font-size: 11px; color: var(--slate-500); margin-top: 6px; }\n        \n        .sources-section {\n          background: white;\n          border-radius: 16px;\n          padding: 28px;\n          margin-bottom: 50px;\n          box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04);\n        }\n        .sources-title {\n          font-size: 11px;\n          font-weight: 600;\n          letter-spacing: 1.2px;\n          text-transform: uppercase;\n          color: var(--slate-500);\n          margin-bottom: 16px;\n        }\n        .sources-grid {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 12px;\n        }\n        .source-badge {\n          display: flex;\n          align-items: center;\n          gap: 8px;\n          padding: 10px 16px;\n          background: var(--slate-50);\n          border-radius: 8px;\n          font-size: 13px;\n          color: var(--slate-700);\n          border: 1px solid var(--slate-200);\n        }\n        .source-badge::before { content: 'üìä'; font-size: 14px; }\n        .source-badge.orcid::before { content: 'üÜî'; }\n        .source-badge.scopus::before { content: 'üìö'; }\n        .source-badge.scholar::before { content: 'üéì'; }\n        .source-badge.university_web_profile::before { content: 'üèõÔ∏è'; }\n        .source-badge.patents::before { content: 'üí°'; }\n        .source-badge.grants::before { content: 'üí∞'; }\n        \n        .researcher-card { background: white; border-radius: 20px; padding: 40px; margin-bottom: 50px; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04); }\n        .researcher-header { display: flex; align-items: flex-start; gap: 32px; margin-bottom: 32px; }\n        .researcher-avatar { width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(135deg, var(--slate-800) 0%, var(--slate-600) 100%); display: flex; align-items: center; justify-content: center; flex-shrink: 0; }\n        .researcher-avatar span { font-family: 'DM Serif Display', serif; font-size: 36px; color: white; }\n        .researcher-info h2 { font-family: 'DM Serif Display', serif; font-size: 32px; color: var(--slate-900); margin-bottom: 8px; }\n        .researcher-institution { font-size: 16px; color: var(--slate-600); margin-bottom: 16px; }\n        .researcher-ids { display: flex; gap: 24px; flex-wrap: wrap; }\n        .researcher-id { display: flex; align-items: center; gap: 8px; font-size: 13px; }\n        .researcher-id-label { color: var(--slate-500); font-weight: 500; }\n        .researcher-id-value { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--slate-700); background: var(--slate-100); padding: 4px 10px; border-radius: 4px; }\n        .reasoning-block { background: var(--slate-50); border-left: 4px solid var(--slate-300); padding: 24px; border-radius: 0 12px 12px 0; }\n        .reasoning-label { font-size: 11px; font-weight: 600; letter-spacing: 1.2px; text-transform: uppercase; color: var(--slate-500); margin-bottom: 12px; }\n        .reasoning-text { font-size: 15px; color: var(--slate-700); line-height: 1.7; }\n        .section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 30px; }\n        .section-title { font-family: 'DM Serif Display', serif; font-size: 28px; color: var(--slate-900); }\n        .section-title .taxonomy-label { font-family: 'IBM Plex Sans', sans-serif; font-size: 12px; font-weight: 600; color: var(--slate-400); display: block; margin-bottom: 4px; }\n        .section-count { font-size: 14px; color: var(--slate-500); }\n        .tier-section-header { display: flex; align-items: center; gap: 12px; margin-bottom: 20px; margin-top: 10px; }\n        .tier-section-title { font-family: 'IBM Plex Sans', sans-serif; font-size: 14px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; }\n        .tier-section-title.primary { color: var(--gold-600); }\n        .tier-section-title.secondary { color: var(--silver-500); }\n        .tier-section-line { flex: 1; height: 2px; border-radius: 1px; }\n        .tier-section-line.primary { background: linear-gradient(90deg, var(--gold-500), transparent); }\n        .tier-section-line.secondary { background: linear-gradient(90deg, var(--silver-400), transparent); }\n        .tier-section-count { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--slate-500); }\n        .classifications-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; margin-bottom: 30px; }\n        .classifications-grid.four-col { grid-template-columns: repeat(4, 1fr); }\n        .classification-card { background: white; border-radius: 16px; padding: 28px; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04); position: relative; overflow: hidden; }\n        .classification-card.fos { border-left: 4px solid var(--teal-500); }\n        .classification-card.tier-primary-card { border-left: 4px solid var(--gold-500); }\n        .classification-card.tier-secondary-card { border-left: 4px solid var(--silver-400); }\n        .classification-code { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; flex-wrap: wrap; gap: 8px; }\n        .code-badge { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 500; background: var(--slate-100); padding: 4px 10px; border-radius: 4px; color: var(--slate-700); }\n        .code-badge.fos { background: rgba(20, 184, 166, 0.1); color: var(--teal-500); }\n        .confidence-pill { font-size: 12px; font-weight: 600; padding: 4px 10px; border-radius: 12px; background: rgba(16, 185, 129, 0.1); color: var(--emerald-600); }\n        .tier-badge { font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 4px; letter-spacing: 0.5px; }\n        .tier-badge.tier-primary { background: linear-gradient(135deg, var(--gold-500), #fcd34d); color: #713f12; }\n        .tier-badge.tier-secondary { background: var(--slate-200); color: var(--slate-600); }\n        .classification-name { font-size: 17px; font-weight: 600; color: var(--slate-900); margin-bottom: 14px; line-height: 1.4; }\n        .classification-justification { font-size: 13px; color: var(--slate-600); margin-bottom: 16px; line-height: 1.6; }\n        .evidence-section { border-top: 1px solid var(--slate-200); padding-top: 14px; }\n        .evidence-label { font-size: 9px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; color: var(--slate-400); margin-bottom: 8px; }\n        .evidence-tags { display: flex; flex-wrap: wrap; gap: 6px; }\n        .evidence-tag { font-size: 11px; padding: 4px 10px; background: var(--slate-100); color: var(--slate-600); border-radius: 4px; }\n        .assessment-grid-wrapper { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; margin-bottom: 24px; }\n        .footer-card { background: white; border-radius: 16px; padding: 28px; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04); }\n        .footer-card-title { font-size: 11px; font-weight: 600; letter-spacing: 1.2px; text-transform: uppercase; color: var(--slate-500); margin-bottom: 20px; }\n        .assessment-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }\n        .assessment-item { text-align: center; }\n        .assessment-label { font-size: 10px; font-weight: 500; color: var(--slate-400); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }\n        .assessment-value { font-family: 'JetBrains Mono', monospace; font-size: 16px; font-weight: 500; }\n        .assessment-value.pass { color: var(--emerald-600); }\n        .assessment-value.fail { color: var(--rose-500); }\n        .assessment-value.neutral { color: var(--slate-600); }\n        .assessment-value.boost { color: var(--emerald-600); }\n        .assessment-value.skip { color: var(--slate-400); }\n        \n        /* v3.8.3: Flag details styles */\n        .flags-detail { margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--slate-200); }\n        .flags-label { font-size: 9px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; color: var(--slate-400); margin-bottom: 8px; }\n        .flag-item { font-size: 12px; color: var(--slate-600); margin-bottom: 6px; padding: 8px; background: var(--slate-50); border-radius: 4px; }\n        .flag-rule { font-weight: 600; color: var(--amber-600); }\n        .flag-code { font-family: 'JetBrains Mono', monospace; font-size: 11px; display: block; margin-top: 4px; }\n        \n        .storage-items { display: flex; flex-direction: column; gap: 12px; }\n        .storage-item { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--slate-50); border-radius: 8px; }\n        .storage-item-left { display: flex; align-items: center; gap: 12px; }\n        .storage-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; color: white; }\n        .storage-icon.neo4j { background: #018bff; }\n        .storage-icon.qdrant { background: #dc244c; }\n        .storage-icon.postgres { background: #336791; }\n        .storage-name { font-size: 13px; color: var(--slate-700); }\n        .storage-status { font-size: 11px; font-weight: 600; color: var(--emerald-600); }\n        .metadata-footer { display: flex; align-items: center; justify-content: space-between; padding: 24px 32px; background: white; border-radius: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 8px 24px rgba(0,0,0,0.04); }\n        .metadata-items { display: flex; gap: 32px; }\n        .metadata-item { display: flex; flex-direction: column; gap: 4px; }\n        .metadata-label { font-size: 10px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; color: var(--slate-400); }\n        .metadata-value { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--slate-600); }\n        .workflow-badge { display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: var(--slate-900); color: var(--slate-100); border-radius: 8px; font-size: 12px; font-weight: 600; }\n        .workflow-badge svg { width: 16px; height: 16px; }\n        @media (max-width: 1024px) { .stats-grid { grid-template-columns: repeat(3, 1fr); } .classifications-grid, .classifications-grid.four-col { grid-template-columns: 1fr; } .assessment-grid-wrapper { grid-template-columns: 1fr; } }\n        @media (max-width: 768px) { .container { padding: 30px 20px; } .report-title { font-size: 36px; } .stats-grid { grid-template-columns: 1fr 1fr; } .researcher-header { flex-direction: column; align-items: center; text-align: center; } .metadata-footer { flex-direction: column; gap: 20px; align-items: flex-start; } .metadata-items { flex-wrap: wrap; gap: 16px; } }\n    </style>\n</head>\n<body>\n    <div class=\"noise-overlay\"></div>\n    <div class=\"container\">\n        <header class=\"report-header\">\n            <div class=\"report-meta\">\n                <span class=\"report-badge dual\">Dual-Standard Classification</span>\n                <span class=\"report-id\">OBJECT-3 ‚Ä¢ v3.8.3 ‚Ä¢ Gen 4</span>\n            </div>\n            <h1 class=\"report-title\">Research Classification</h1>\n            <p class=\"report-subtitle\">ANZSRC FoR 2020 + OECD FOS 2007 Assessment for <strong>${name}</strong></p>\n        </header>\n\n        <div class=\"stats-grid\">\n            <div class=\"stat-card confidence\"><div class=\"stat-label\">Final Confidence</div><div class=\"stat-value confidence\">${formatConfidence(finalConfidence)}<span class=\"stat-suffix\">%</span></div></div>\n            <div class=\"stat-card tier-primary\"><div class=\"stat-label\">Primary Codes</div><div class=\"stat-value gold\">${primaryCount}</div><div class=\"stat-sub\">Core expertise (1-3)</div></div>\n            <div class=\"stat-card tier-secondary\"><div class=\"stat-label\">Secondary Codes</div><div class=\"stat-value silver\">${secondaryCount}</div><div class=\"stat-sub\">Supporting (4-8)</div></div>\n            <div class=\"stat-card codes-b\"><div class=\"stat-label\">OECD FOS Codes</div><div class=\"stat-value\">${oecdCount}</div><div class=\"stat-sub\">Domain Hub</div></div>\n            <div class=\"stat-card crosswalk\"><div class=\"stat-label\">Crosswalk</div><div class=\"stat-value ${crosswalk.alignment_score >= 0.50 ? 'confidence' : 'amber'}\">${crosswalk.alignment_score !== null ? formatConfidence(crosswalk.alignment_score) : 'N/A'}<span class=\"stat-suffix\">%</span></div><div class=\"stat-sub\">${crosswalk.modifier >= 0 ? '+' : ''}${Math.round((crosswalk.modifier || 0) * 100)}% ${crosswalk.modifier >= 0 ? 'boost' : 'penalty'}</div></div>\n            <div class=\"stat-card routing\"><div class=\"stat-label\">Routing</div><div class=\"stat-badge ${getRoutingBadgeClass(routingRecommendation)}\">${formatRoutingLabel(routingRecommendation)}</div></div>\n        </div>\n\n        ${sourcesHTML}\n\n        <div class=\"researcher-card\">\n            <div class=\"researcher-header\">\n                <div class=\"researcher-avatar\"><span>${initials}</span></div>\n                <div class=\"researcher-info\">\n                    <h2>${name}</h2>\n                    <p class=\"researcher-institution\">${institution}</p>\n                    <div class=\"researcher-ids\"><div class=\"researcher-id\"><span class=\"researcher-id-label\">Asset ID</span><span class=\"researcher-id-value\">${assetId}</span></div></div>\n                </div>\n            </div>\n            <div class=\"reasoning-block\"><div class=\"reasoning-label\">Classification Reasoning</div><p class=\"reasoning-text\">${reasoning}</p></div>\n        </div>\n\n        <!-- v3.8.3 FIX: Use primaryCount + secondaryCount instead of anzsrcCount -->\n        <div class=\"section-header\"><h2 class=\"section-title\"><span class=\"taxonomy-label\">Standard A ‚Äî ANZSRC FoR 2020</span>Primary Classifications</h2><span class=\"section-count\">${primaryCount + secondaryCount} codes assigned (${primaryCount} primary + ${secondaryCount} secondary)</span></div>\n        \n        ${primaryCodes.length > 0 ? `\n        <div class=\"tier-section-header\">\n            <span class=\"tier-section-title primary\">‚òÖ Primary Expertise</span>\n            <div class=\"tier-section-line primary\"></div>\n            <span class=\"tier-section-count\">${primaryCount} codes</span>\n        </div>\n        <div class=\"classifications-grid\">\n            ${primaryCodes.map(c => `<div class=\"classification-card tier-primary-card\"><div class=\"classification-code\"><span class=\"code-badge\">${c.code}</span>${getTierBadge(c.tier, c.rank)}<span class=\"confidence-pill\">${formatConfidence(c.confidence)}%</span></div><h3 class=\"classification-name\">${c.name}</h3><p class=\"classification-justification\">${c.justification || 'No justification provided.'}</p>${c.evidence && c.evidence.length > 0 ? `<div class=\"evidence-section\"><div class=\"evidence-label\">Evidence</div><div class=\"evidence-tags\">${c.evidence.map(e => `<span class=\"evidence-tag\">${e}</span>`).join('')}</div></div>` : ''}</div>`).join('')}\n        </div>\n        ` : ''}\n        \n        ${secondaryCodes.length > 0 ? `\n        <div class=\"tier-section-header\">\n            <span class=\"tier-section-title secondary\">‚óá Secondary Expertise</span>\n            <div class=\"tier-section-line secondary\"></div>\n            <span class=\"tier-section-count\">${secondaryCount} codes</span>\n        </div>\n        <div class=\"classifications-grid\">\n            ${secondaryCodes.map(c => `<div class=\"classification-card tier-secondary-card\"><div class=\"classification-code\"><span class=\"code-badge\">${c.code}</span>${getTierBadge(c.tier, c.rank)}<span class=\"confidence-pill\">${formatConfidence(c.confidence)}%</span></div><h3 class=\"classification-name\">${c.name}</h3><p class=\"classification-justification\">${c.justification || 'No justification provided.'}</p>${c.evidence && c.evidence.length > 0 ? `<div class=\"evidence-section\"><div class=\"evidence-label\">Evidence</div><div class=\"evidence-tags\">${c.evidence.map(e => `<span class=\"evidence-tag\">${e}</span>`).join('')}</div></div>` : ''}</div>`).join('')}\n        </div>\n        ` : ''}\n\n        <div class=\"section-header\" style=\"margin-top: 50px;\"><h2 class=\"section-title\"><span class=\"taxonomy-label\">Standard B ‚Äî OECD Fields of Science 2007</span>Domain Hub Classifications</h2><span class=\"section-count\">${oecdCount} codes assigned</span></div>\n        <!-- v3.8.3 FIX: Added evidence display for OECD FOS codes -->\n        <div class=\"classifications-grid four-col\">\n            ${oecdClassifications.map(c => `<div class=\"classification-card fos\"><div class=\"classification-code\"><span class=\"code-badge fos\">${c.code}</span><span class=\"confidence-pill\">${formatConfidence(c.confidence)}%</span></div><h3 class=\"classification-name\">${c.name}</h3><p class=\"classification-justification\">${c.justification || 'Domain mapping based on research profile.'}</p>${c.evidence && c.evidence.length > 0 ? `<div class=\"evidence-section\"><div class=\"evidence-label\">Evidence</div><div class=\"evidence-tags\">${c.evidence.map(e => `<span class=\"evidence-tag\">${e}</span>`).join('')}</div></div>` : ''}</div>`).join('')}\n        </div>\n\n        <!-- v3.8.3 FIX: Added CRE Assessment section and flag details -->\n        <div class=\"assessment-grid-wrapper\">\n            <div class=\"footer-card\">\n                <div class=\"footer-card-title\">CF1 Constraint Assessment</div>\n                <div class=\"assessment-grid\">\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Status</div><div class=\"assessment-value ${cf1.passed ? 'pass' : 'fail'}\">${cf1.passed ? 'Passed' : 'Failed'}</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Violations</div><div class=\"assessment-value neutral\">${cf1.violations || 0}</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Flags</div><div class=\"assessment-value neutral\">${cf1.flags || 0}</div></div>\n                </div>\n                ${cf1FlagsHTML}\n            </div>\n            <div class=\"footer-card\">\n                <div class=\"footer-card-title\">CRE Assessment</div>\n                <div class=\"assessment-grid\">\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">CF1 TRL</div><div class=\"assessment-value ${cre.cf1_trl?.passed ? 'pass' : cre.cf1_trl?.skipped ? 'skip' : 'fail'}\">${cre.cf1_trl?.passed ? (cre.cf1_trl?.skipped ? 'Skipped' : 'Passed') : cre.cf1_trl?.skipped ? 'Skipped' : 'Failed'}${cre.cf1_trl?.inferred_level ? ' (L' + cre.cf1_trl.inferred_level + ')' : ''}</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">CF5 Regulatory</div><div class=\"assessment-value ${cre.cf5_regulatory?.passed ? 'pass' : cre.cf5_regulatory?.skipped ? 'skip' : 'fail'}\">${cre.cf5_regulatory?.passed ? (cre.cf5_regulatory?.skipped ? 'Skipped' : 'Passed') : cre.cf5_regulatory?.skipped ? 'Skipped' : 'Failed'}</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">HITL Required</div><div class=\"assessment-value ${cre.requires_hitl ? 'fail' : 'pass'}\">${cre.requires_hitl ? 'Yes' : 'No'}</div></div>\n                </div>\n            </div>\n            <div class=\"footer-card\">\n                <div class=\"footer-card-title\">Crosswalk Assessment</div>\n                <div class=\"assessment-grid\">\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Alignment</div><div class=\"assessment-value ${crosswalk.alignment_score >= 0.50 ? 'pass' : crosswalk.alignment_score >= 0.30 ? 'neutral' : 'fail'}\">${crosswalk.alignment_score !== null ? formatConfidence(crosswalk.alignment_score) + '%' : 'N/A'}</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Modifier</div><div class=\"assessment-value ${crosswalk.modifier >= 0 ? 'boost' : 'fail'}\">${crosswalk.modifier >= 0 ? '+' : ''}${Math.round((crosswalk.modifier || 0) * 100)}%</div></div>\n                    <div class=\"assessment-item\"><div class=\"assessment-label\">Mappings</div><div class=\"assessment-value neutral\">${crosswalk.mappings_checked || 0}</div></div>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"assessment-grid-wrapper\">\n            <div class=\"footer-card\" style=\"grid-column: span 3;\">\n                <div class=\"footer-card-title\">Storage Sync</div>\n                <div class=\"storage-items\" style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;\">\n                    <div class=\"storage-item\"><div class=\"storage-item-left\"><div class=\"storage-icon neo4j\">N</div><span class=\"storage-name\">Neo4j ‚Äî ${neo4jRelationships} relationships</span></div><span class=\"storage-status\">${storage.neo4j?.status || 'Success'}</span></div>\n                    <div class=\"storage-item\"><div class=\"storage-item-left\"><div class=\"storage-icon qdrant\">Q</div><span class=\"storage-name\">Qdrant ‚Äî Payload updated</span></div><span class=\"storage-status\">${storage.qdrant?.status || 'OK'}</span></div>\n                    <div class=\"storage-item\"><div class=\"storage-item-left\"><div class=\"storage-icon postgres\">P</div><span class=\"storage-name\">PostgreSQL ‚Äî Log #${postgresLogId}</span></div><span class=\"storage-status\">${storage.postgresql?.status || 'Success'}</span></div>\n                </div>\n            </div>\n        </div>\n\n        <footer class=\"metadata-footer\">\n            <div class=\"metadata-items\">\n                <div class=\"metadata-item\"><span class=\"metadata-label\">Classified At</span><span class=\"metadata-value\">${classifiedAt}</span></div>\n                <div class=\"metadata-item\"><span class=\"metadata-label\">Classified By</span><span class=\"metadata-value\">${classifiedBy}</span></div>\n                <div class=\"metadata-item\"><span class=\"metadata-label\">Model</span><span class=\"metadata-value\">${model}</span></div>\n                <div class=\"metadata-item\"><span class=\"metadata-label\">Job ID</span><span class=\"metadata-value\">${jobId}</span></div>\n            </div>\n            <div class=\"workflow-badge\"><svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z\"/><path d=\"M9 12l2 2 4-4\"/></svg>OBJECT-3 v3.8.3</div>\n        </footer>\n    </div>\n</body>\n</html>`;\n\n  return html;\n}\n\nreturn results.map(item => {\n  const html = generateClassificationHTML(item.json);\n  const researcherName = (item.json.name || 'Researcher').replace(/[^a-zA-Z0-9]/g, '_');\n  return {\n    json: {\n      ...item.json,\n      html: html,\n      researcher_profile: { researcher_name: item.json.name || 'Unknown' }\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2016,
        2864
      ],
      "id": "35703dc1-1f03-4e01-a0bd-bd62da86382a",
      "name": "JSON to HTML"
    },
    {
      "parameters": {
        "jsCode": "// Prepare HTML as Binary File for Gotenberg\n// FIXED: Get data from JSON to HTML node directly (not from input)\nconst inputData = $('JSON to HTML').item.json;\nconst htmlContent = inputData.html;\n\nif (!htmlContent) {\n  throw new Error('No HTML content found in item');\n}\n\nconst researcherName = inputData.name || inputData.researcher_profile?.researcher_name || 'Unknown';\nconsole.log('Converting HTML to binary for:', researcherName);\n\nconst binaryData = Buffer.from(htmlContent, 'utf-8');\n\nreturn {\n  json: { ...inputData, html: undefined },\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'text/html',\n      fileName: 'index.html',\n      fileExtension: 'html'\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2944,
        2864
      ],
      "id": "8951edfc-e08d-43ee-9c77-1cfdbe0a0846",
      "name": "Prepare HTML as Binary File"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://134.199.152.159:3000/forms/chromium/convert/html",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3184,
        2864
      ],
      "id": "d91e85ac-87b8-45ea-b1fb-3b4b653a854a",
      "name": "HTML to PDF(Gotenberg)",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "jsCode": "// Edit Binary Metadata - Set PDF filename\nconst data = $json;\nconst binary = $binary;\n\nconst researcherName = data.name || data.researcher_profile?.researcher_name || 'Unknown_Researcher';\nconsole.log('Setting PDF filename for:', researcherName);\n\nconst cleanName = researcherName.replace(/[^a-zA-Z0-9]/g, '_');\nconst timestamp = new Date().toISOString().slice(0, 10);\nconst filename = `${cleanName}_Classification_${timestamp}.pdf`;\n\nconsole.log('Filename:', filename);\n\nif (binary?.data) {\n  binary.data.fileName = filename;\n  binary.data.mimeType = 'application/pdf';\n}\n\nreturn {\n  json: { ...data, pdf_filename: filename },\n  binary: binary\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3424,
        2864
      ],
      "id": "aef807eb-e7e7-42ba-9d2b-198558f690c4",
      "name": "Edit Binary Metadata"
    },
    {
      "parameters": {
        "name": "={{ $json.name || $json.researcher_profile?.researcher_name || 'Classification_Report' }}",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "1BcH-FOm5kUmdQUxuq9qaxM-f-jA2fmFn",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        3664,
        2864
      ],
      "id": "a4c500a0-4238-4192-a117-bb841fa785f7",
      "name": "Upload file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "HVpWOvlA9BuTQtEK",
          "name": "Google Drive (biotech3220)"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "id": "e9d644b6-888a-4bd9-9792-e1437cb877fe",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        -224,
        1968
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Calculate Final Confidence\n// Version: v3.8.3\n// Gen 4 + v3.7: Includes CRE blocking + data quality penalty\n// v3.8: Added tier assignment (Step 7a)\n// v3.8.3: Sparse data support - always classify, OBJECT-4 routes\n// ============================================================\n\nconst inputData = $input.first().json;\n\nconst classifications = inputData.classifications || [];\nconst cf1Penalty = inputData.cf1_assessment?.penalty || 0.0;\nconst crosswalkModifier = inputData.crosswalk_assessment?.modifier || 0.0;\nconst creAssessment = inputData.cre_assessment || {};\n\n// ============================================================\n// v3.8.3: DATA QUALITY PENALTY (includes sparse data)\n// - Sparse data: -25% penalty (set by Check Data Quality)\n// - Partial data: -10% penalty\n// Per Definition Card: OBJECT-3 classifies ALL, OBJECT-4 routes\n// ============================================================\nconst dataQuality = inputData.data_quality || {};\nconst dataQualityPenalty = dataQuality.confidence_penalty || 0;\nconst isSparseData = dataQuality.is_sparse || false;\nconst forceHumanReview = dataQuality.has_issue || isSparseData;\n\nif (isSparseData) {\n  console.log(`‚ö†Ô∏è SPARSE DATA DETECTED (v3.8.3):`);\n  console.log(`   Missing fields: ${(dataQuality.missing_fields || []).join(', ')}`);\n  console.log(`   Applying -${(dataQualityPenalty * 100).toFixed(0)}% confidence penalty`);\n  console.log(`   Will proceed to classification (OBJECT-4 handles routing)`);\n} else if (dataQuality.has_issue) {\n  console.log(`‚ö†Ô∏è DATA QUALITY WARNING (v3.7):`);\n  console.log(`   Missing fields: ${(dataQuality.missing_fields || []).join(', ')}`);\n  console.log(`   Applying -${(dataQualityPenalty * 100).toFixed(0)}% confidence penalty`);\n}\n\n// ============================================================\n// GEN 4: CHECK FOR BLOCKING CONSTRAINT FAILURES\n// ============================================================\nif (creAssessment.blocking_failures?.length > 0) {\n  console.log(`üö´ BLOCKED by CRE constraints: ${creAssessment.blocking_failures.join(', ')}`);\n  \n  return [{\n    json: {\n      asset_id: inputData.asset_id,\n      name: inputData.name,\n      qdrant_point_id: inputData.qdrant_point_id,\n      reasoning: inputData.reasoning,\n      model: inputData.model,\n      \n      cf1_assessment: inputData.cf1_assessment,\n      crosswalk_assessment: inputData.crosswalk_assessment,\n      cre_assessment: inputData.cre_assessment,\n      data_quality: inputData.data_quality,\n      \n      classifications: [],\n      classification_count: 0,\n      tier_summary: { primary_count: 0, secondary_count: 0, untiered_count: 0 },\n      standard_b_classifications: inputData.standard_b_classifications,\n      standard_b_count: inputData.standard_b_count,\n      \n      final_confidence: 0.0,\n      confidence_breakdown: {\n        base_mean: 0,\n        cf1_penalty: cf1Penalty,\n        crosswalk_modifier: crosswalkModifier,\n        cre_penalty: creAssessment.cre_penalty || 0,\n        data_quality_penalty: dataQualityPenalty,\n        net_adjustment: 0\n      },\n      \n      classification_failed: true,\n      classification_blocked: true,\n      force_human_review: true,\n      is_sparse_data: isSparseData,\n      requires_human_review: true,\n      failure_reason: `Blocked by CRE constraints: ${creAssessment.blocking_failures.join(', ')}`,\n      blocking_constraints: creAssessment.blocking_failures,\n      routing_recommendation: 'REJECT',\n      \n      thresholds_applied: {\n        fail_threshold: 0.60,\n        auto_approve_threshold: 0.85,\n        min_code_confidence: 0.70\n      },\n      \n      classified_at: new Date().toISOString(),\n      workflow_version: 'OBJECT-3_v3.8.3'\n    }\n  }];\n}\n\n// ============================================================\n// CHECK FOR EMPTY CLASSIFICATIONS\n// v3.8.3: Don't fail - route to OBJECT-4 with zero confidence\n// ============================================================\nif (classifications.length === 0) {\n  console.log(`‚ö†Ô∏è No classifications generated - routing with zero confidence`);\n  \n  return [{\n    json: {\n      asset_id: inputData.asset_id,\n      name: inputData.name,\n      qdrant_point_id: inputData.qdrant_point_id,\n      reasoning: inputData.reasoning || 'No classifications could be generated',\n      model: inputData.model,\n      \n      cf1_assessment: inputData.cf1_assessment,\n      crosswalk_assessment: inputData.crosswalk_assessment,\n      cre_assessment: inputData.cre_assessment,\n      data_quality: inputData.data_quality,\n      \n      classifications: [],\n      classification_count: 0,\n      tier_summary: { primary_count: 0, secondary_count: 0, untiered_count: 0 },\n      standard_b_classifications: inputData.standard_b_classifications || [],\n      standard_b_count: inputData.standard_b_count || 0,\n      \n      final_confidence: 0.0,\n      confidence_breakdown: {\n        base_mean: 0,\n        cf1_penalty: cf1Penalty,\n        crosswalk_modifier: crosswalkModifier,\n        cre_penalty: creAssessment.cre_penalty || 0,\n        data_quality_penalty: dataQualityPenalty,\n        net_adjustment: 0\n      },\n      \n      classification_failed: false,\n      classification_blocked: false,\n      force_human_review: true,\n      is_sparse_data: isSparseData,\n      requires_human_review: true,\n      failure_reason: null,\n      routing_recommendation: 'HUMAN_REVIEW',\n      \n      thresholds_applied: {\n        fail_threshold: 0.60,\n        auto_approve_threshold: 0.85,\n        min_code_confidence: 0.70\n      },\n      \n      classified_at: new Date().toISOString(),\n      workflow_version: 'OBJECT-3_v3.8.3'\n    }\n  }];\n}\n\n// ============================================================\n// CALCULATE CONFIDENCE WITH ALL MODIFIERS\n// Includes: CF1, Crosswalk, CRE, Data Quality (v3.7+)\n// ============================================================\nconst crePenalty = creAssessment.cre_penalty || 0.0;\n\nconst adjustedClassifications = classifications.map(c => {\n  const totalAdjustment = -cf1Penalty + crosswalkModifier - crePenalty - dataQualityPenalty;\n  const adjustedConfidence = Math.max(0.0, Math.min(1.0, c.confidence + totalAdjustment));\n  \n  return {\n    ...c,\n    base_confidence: c.confidence,\n    adjustments: {\n      cf1: -cf1Penalty,\n      crosswalk: crosswalkModifier,\n      cre: -crePenalty,\n      data_quality: -dataQualityPenalty,\n      total: Math.round(totalAdjustment * 10000) / 10000\n    },\n    adjusted_confidence: Math.round(adjustedConfidence * 10000) / 10000\n  };\n});\n\n// ============================================================\n// v3.8: STEP 7a - ASSIGN CLASSIFICATION TIERS\n// - Rank codes by confidence (highest first)\n// - Assign tier = \"primary\" to ranks 1-3\n// - Assign tier = \"secondary\" to ranks 4-8\n// - Codes ranked 9+ receive tier = null\n// ============================================================\n\nadjustedClassifications.sort((a, b) => b.adjusted_confidence - a.adjusted_confidence);\n\nconst tieredClassifications = adjustedClassifications.map((c, index) => {\n  const rank = index + 1;\n  let tier = null;\n  \n  if (rank <= 3) {\n    tier = \"primary\";\n  } else if (rank <= 8) {\n    tier = \"secondary\";\n  }\n  \n  return {\n    ...c,\n    rank: rank,\n    tier: tier\n  };\n});\n\nconst tierSummary = {\n  primary_count: tieredClassifications.filter(c => c.tier === 'primary').length,\n  secondary_count: tieredClassifications.filter(c => c.tier === 'secondary').length,\n  untiered_count: tieredClassifications.filter(c => c.tier === null).length\n};\n\n// ============================================================\n// CALCULATE FINAL CONFIDENCE\n// ============================================================\nconst confidences = tieredClassifications.map(c => c.adjusted_confidence);\nconst baseMean = classifications.reduce((a, c) => a + c.confidence, 0) / classifications.length;\nconst finalConfidence = Math.round((confidences.reduce((a, b) => a + b, 0) / confidences.length) * 10000) / 10000;\n\n// ============================================================\n// DETERMINE ROUTING SIGNALS\n// - Auto-Approve: >= 0.85\n// - Human Review: 0.60-0.85\n// - Rejection: < 0.60\n// v3.8.3: OBJECT-4 makes final routing decision\n// ============================================================\nconst FAIL_THRESHOLD = 0.60;\nconst AUTO_APPROVE_THRESHOLD = 0.85;\n\nconst classificationFailed = finalConfidence < FAIL_THRESHOLD;\nconst failureReason = classificationFailed \n  ? `Final confidence ${finalConfidence.toFixed(2)} below threshold ${FAIL_THRESHOLD}`\n  : null;\n\nconst requiresHumanReview = forceHumanReview || (finalConfidence >= FAIL_THRESHOLD && finalConfidence < AUTO_APPROVE_THRESHOLD);\n\nlet routingRecommendation = 'REJECT';\nif (finalConfidence >= FAIL_THRESHOLD) {\n  if (forceHumanReview || isSparseData) {\n    routingRecommendation = 'HUMAN_REVIEW';\n  } else if (finalConfidence >= AUTO_APPROVE_THRESHOLD) {\n    routingRecommendation = 'AUTO_APPROVE';\n  } else {\n    routingRecommendation = 'HUMAN_REVIEW';\n  }\n}\n\n// ============================================================\n// LOG SUMMARY\n// ============================================================\nconsole.log(`\\n============================================================`);\nconsole.log(`‚úÖ CONFIDENCE CALCULATION COMPLETE (v3.8.3)`);\nconsole.log(`============================================================`);\nconsole.log(`   Researcher: ${inputData.name}`);\nconsole.log(`   Classifications: ${tieredClassifications.length} codes`);\nconsole.log(`   Sparse Data: ${isSparseData ? 'YES ‚ö†Ô∏è' : 'NO'}`);\nconsole.log(`\\n   CONFIDENCE BREAKDOWN:`);\nconsole.log(`   ‚îú‚îÄ Base mean:           ${baseMean.toFixed(3)}`);\nconsole.log(`   ‚îú‚îÄ CF1 penalty:         ${cf1Penalty > 0 ? '-' : ' '}${(cf1Penalty * 100).toFixed(0)}%`);\nconsole.log(`   ‚îú‚îÄ Crosswalk modifier:  ${crosswalkModifier >= 0 ? '+' : ''}${(crosswalkModifier * 100).toFixed(0)}%`);\nconsole.log(`   ‚îú‚îÄ CRE penalty:         ${crePenalty > 0 ? '-' : ' '}${(crePenalty * 100).toFixed(0)}%`);\nconsole.log(`   ‚îú‚îÄ Data quality penalty:${dataQualityPenalty > 0 ? '-' : ' '}${(dataQualityPenalty * 100).toFixed(0)}%`);\nconsole.log(`   ‚îî‚îÄ FINAL CONFIDENCE:    ${finalConfidence.toFixed(3)}`);\nconsole.log(`\\n   TIER ASSIGNMENT (v3.8):`);\nconsole.log(`   ‚îú‚îÄ Primary (1-3):       ${tierSummary.primary_count} codes`);\nconsole.log(`   ‚îú‚îÄ Secondary (4-8):     ${tierSummary.secondary_count} codes`);\nconsole.log(`   ‚îî‚îÄ Untiered (9+):       ${tierSummary.untiered_count} codes`);\nconsole.log(`\\n   ROUTING (recommendation for OBJECT-4):`);\nconsole.log(`   ‚îú‚îÄ Classification failed: ${classificationFailed}`);\nconsole.log(`   ‚îú‚îÄ Force human review:    ${forceHumanReview}`);\nconsole.log(`   ‚îú‚îÄ Is sparse data:        ${isSparseData}`);\nconsole.log(`   ‚îî‚îÄ Recommendation:        ${routingRecommendation}`);\nconsole.log(`============================================================\\n`);\n\n// ============================================================\n// RETURN OUTPUT\n// ============================================================\nreturn [{\n  json: {\n    asset_id: inputData.asset_id,\n    name: inputData.name,\n    orcid: inputData.orcid,\n    institution: inputData.institution,\n    qdrant_point_id: inputData.qdrant_point_id,\n    \n    reasoning: inputData.reasoning,\n    model: inputData.model,\n    \n    cf1_assessment: inputData.cf1_assessment,\n    crosswalk_assessment: inputData.crosswalk_assessment,\n    cre_assessment: inputData.cre_assessment,\n    data_quality: inputData.data_quality,\n    \n    retrieval_sources: inputData.retrieval_sources,\n    matched_groups: inputData.matched_groups,\n    \n    classifications: tieredClassifications,\n    classification_count: tieredClassifications.length,\n    tier_summary: tierSummary,\n    \n    standard_b_classifications: inputData.standard_b_classifications,\n    standard_b_count: inputData.standard_b_count,\n    \n    final_confidence: finalConfidence,\n    confidence_breakdown: {\n      base_mean: Math.round(baseMean * 10000) / 10000,\n      cf1_penalty: cf1Penalty,\n      crosswalk_modifier: crosswalkModifier,\n      cre_penalty: crePenalty,\n      data_quality_penalty: dataQualityPenalty,\n      net_adjustment: Math.round((-cf1Penalty + crosswalkModifier - crePenalty - dataQualityPenalty) * 10000) / 10000\n    },\n    \n    classification_failed: classificationFailed,\n    classification_blocked: false,\n    force_human_review: forceHumanReview,\n    requires_human_review: requiresHumanReview,\n    is_sparse_data: isSparseData,\n    failure_reason: failureReason,\n    routing_recommendation: routingRecommendation,\n    \n    thresholds_applied: {\n      fail_threshold: FAIL_THRESHOLD,\n      auto_approve_threshold: AUTO_APPROVE_THRESHOLD,\n      min_code_confidence: 0.70\n    },\n    \n    classified_at: new Date().toISOString(),\n    workflow_version: 'OBJECT-3_v3.8.3'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1952,
        2592
      ],
      "id": "4186558a-d37c-4553-bf45-3d8f81bcab77",
      "name": "Calculate Final Confidence & Assign Tiers"
    },
    {
      "parameters": {
        "jsCode": "// Node: Prepare Fetch FATObjects\n// PURPOSE: Fetch specific researcher for testing\n// v3.8.2: Get data_completeness from ThinObject via FABRICATED_FROM\n// ============================================================\n\nconst cypherPayload = {\n  statement: `\n    MATCH (fat:FATObject)\n    WHERE fat.asset_id = 'fat:researcher:colin_barrow'\n    OPTIONAL MATCH (fat)-[:FABRICATED_FROM]->(thin)\n    RETURN \n        fat.asset_id AS asset_id,\n        fat.display_name AS name,\n        fat.orcid_id AS orcid,\n        fat.dense_text AS dense_view,\n        fat.version AS version,\n        fat.provenance AS provenance,\n        thin.data_completeness AS data_completeness\n  `,\n  parameters: {}\n};\n\nconsole.log('‚úÖ TARGETED MODE: Fetching Colin Barrow with data_completeness from ThinObject');\n\nreturn [{\n  json: {\n    fetch_mode: 'targeted_colin_barrow',\n    neo4j_payload: cypherPayload\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        1632
      ],
      "id": "abe9575a-ec2d-4abb-afb7-36e41f989be0",
      "name": "Prepare Fetch FATObjects collin"
    },
    {
      "parameters": {
        "jsCode": "// Get data directly from JSON to HTML (has all the data)\nconst data = $('JSON to HTML').item.json;\n\nconst name = data.name || 'Unknown';\nconst institution = data.institution || 'Institution';\nconst assetId = data.asset_id || 'unknown';\n\nconst dataSources = data.data_sources || {};\nconst sourcesList = dataSources.scraped_from || [];\n\nconst standardA = data.standard_a || {};\nconst anzsrcClassifications = standardA.classifications || [];\nconst primaryCodes = anzsrcClassifications.filter(c => c.tier === 'primary');\nconst secondaryCodes = anzsrcClassifications.filter(c => c.tier === 'secondary');\n\nconst standardB = data.standard_b || {};\nconst oecdClassifications = standardB.classifications || [];\n\nconst assessment = data.assessment || {};\nconst finalConfidence = assessment.final_confidence || 0;\nconst crosswalk = assessment.crosswalk || {};\nconst cf1 = assessment.anzsrc_hierarchy || {};\nconst cre = assessment.cre || {};\nconst confidenceBreakdown = assessment.confidence_breakdown || {};\n\nconst routing = data.routing || {};\nconst storage = data.storage || {};\nconst metadata = data.metadata || {};\nconst reasoning = data.reasoning || '';\n\nlet md = `# Classification Report: ${name}\\n\\n`;\nmd += `**Generated:** ${new Date().toISOString()}\\n\\n`;\nmd += `---\\n\\n`;\n\nmd += `## Summary\\n\\n`;\nmd += `| Metric | Value |\\n`;\nmd += `|--------|-------|\\n`;\nmd += `| **Final Confidence** | ${Math.round(finalConfidence * 100)}% |\\n`;\nmd += `| **Primary Codes** | ${primaryCodes.length} |\\n`;\nmd += `| **Secondary Codes** | ${secondaryCodes.length} |\\n`;\nmd += `| **OECD FOS Codes** | ${oecdClassifications.length} |\\n`;\nmd += `| **Crosswalk Alignment** | ${crosswalk.alignment_score ? Math.round(crosswalk.alignment_score * 100) + '%' : 'N/A'} |\\n`;\nmd += `| **Routing** | ${routing.recommendation || 'N/A'} |\\n\\n`;\n\nmd += `## Data Sources (${sourcesList.length})\\n\\n`;\nsourcesList.forEach(s => { md += `- ${s}\\n`; });\nmd += `\\n`;\n\nmd += `## Researcher Profile\\n\\n`;\nmd += `- **Name:** ${name}\\n`;\nmd += `- **Institution:** ${institution}\\n`;\nmd += `- **Asset ID:** \\`${assetId}\\`\\n\\n`;\n\nif (reasoning) {\n  md += `## Classification Reasoning\\n\\n${reasoning}\\n\\n`;\n}\n\nmd += `## ANZSRC FoR 2020 (${anzsrcClassifications.length} codes)\\n\\n`;\nif (primaryCodes.length > 0) {\n  md += `### ‚òÖ Primary (${primaryCodes.length})\\n\\n`;\n  primaryCodes.forEach(c => {\n    md += `**${c.code} - ${c.name}** (${Math.round((c.confidence || 0) * 100)}%)\\n\\n`;\n    if (c.justification) md += `> ${c.justification}\\n\\n`;\n    if (c.evidence?.length > 0) md += `*Evidence: ${c.evidence.join(', ')}*\\n\\n`;\n  });\n}\nif (secondaryCodes.length > 0) {\n  md += `### ‚óá Secondary (${secondaryCodes.length})\\n\\n`;\n  secondaryCodes.forEach(c => {\n    md += `**${c.code} - ${c.name}** (${Math.round((c.confidence || 0) * 100)}%)\\n\\n`;\n    if (c.justification) md += `> ${c.justification}\\n\\n`;\n    if (c.evidence?.length > 0) md += `*Evidence: ${c.evidence.join(', ')}*\\n\\n`;\n  });\n}\n\nmd += `## OECD FOS 2007 (${oecdClassifications.length} codes)\\n\\n`;\noecdClassifications.forEach(c => {\n  md += `**${c.code} - ${c.name}** (${Math.round((c.confidence || 0) * 100)}%)\\n\\n`;\n  if (c.justification) md += `> ${c.justification}\\n\\n`;\n});\n\nmd += `## Assessments\\n\\n`;\nmd += `### CF1 Constraint\\n\\n`;\nmd += `- **Status:** ${cf1.passed ? '‚úÖ Passed' : '‚ùå Failed'}\\n`;\nmd += `- **Violations:** ${cf1.violations || 0}\\n`;\nmd += `- **Flags:** ${cf1.flags || 0}\\n\\n`;\n\nif (cf1.flags_detail?.length > 0) {\n  md += `**Flag Details:**\\n`;\n  cf1.flags_detail.forEach(f => { md += `- ${f.rule || f.type}: ${f.message || JSON.stringify(f)}\\n`; });\n  md += `\\n`;\n}\n\nmd += `### CRE Assessment\\n\\n`;\nmd += `- **CF1 TRL:** ${cre.cf1_trl?.skipped ? '‚è≠Ô∏è Skipped' : cre.cf1_trl?.passed ? '‚úÖ Passed' : '‚ùå Failed'}\\n`;\nmd += `- **CF5 Regulatory:** ${cre.cf5_regulatory?.skipped ? '‚è≠Ô∏è Skipped' : cre.cf5_regulatory?.passed ? '‚úÖ Passed' : '‚ùå Failed'}\\n`;\nmd += `- **HITL Required:** ${cre.requires_hitl ? '‚ö†Ô∏è Yes' : '‚úÖ No'}\\n\\n`;\n\nmd += `### Crosswalk\\n\\n`;\nmd += `- **Alignment:** ${crosswalk.alignment_score ? Math.round(crosswalk.alignment_score * 100) + '%' : 'N/A'}\\n`;\nmd += `- **Modifier:** ${(crosswalk.modifier || 0) >= 0 ? '+' : ''}${Math.round((crosswalk.modifier || 0) * 100)}%\\n`;\nmd += `- **Mappings:** ${crosswalk.mappings_checked || 0}\\n\\n`;\n\nmd += `## Storage\\n\\n`;\nmd += `- **Neo4j:** ${storage.neo4j?.status || 'N/A'} (${storage.neo4j?.total_relationships || 0} relationships)\\n`;\nmd += `- **Qdrant:** ${storage.qdrant?.status || 'N/A'}\\n`;\nmd += `- **PostgreSQL:** ${storage.postgresql?.status || 'N/A'} (Record #${storage.postgresql?.record_id || 'N/A'})\\n\\n`;\n\nmd += `## Metadata\\n\\n`;\nmd += `- **Classified At:** ${metadata.classified_at || 'N/A'}\\n`;\nmd += `- **Classified By:** ${metadata.classified_by || 'N/A'}\\n`;\nmd += `- **Model:** ${metadata.model || 'N/A'}\\n\\n`;\n\nmd += `---\\n*Classification Foundry v6.4.0*\\n`;\n\nconst cleanName = name.replace(/[^a-zA-Z0-9]/g, '_');\nconst filename = `${cleanName}_Classification_${new Date().toISOString().slice(0,10)}.md`;\n\nreturn [{\n  json: {\n    ...data,\n    markdown_content: md,\n    markdown_filename: filename\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2256,
        2864
      ],
      "id": "61d689c0-388d-4743-a968-7db142c1f90a",
      "name": "Generate Markdown Report"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Markdown as Binary File for Google Drive\nconst inputData = $input.first().json;\nconst mdContent = inputData.markdown_content;\n\nif (!mdContent) {\n  throw new Error('No Markdown content found');\n}\n\nconst filename = inputData.markdown_filename || 'Classification_Report.md';\nconsole.log('Preparing Markdown binary:', filename);\n\nconst binaryData = Buffer.from(mdContent, 'utf-8');\n\nreturn {\n  json: { \n    ...inputData, \n    markdown_content: undefined\n  },\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'text/markdown',\n      fileName: filename,\n      fileExtension: 'md'\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2448,
        2864
      ],
      "id": "48aedaa9-b2ab-4844-bc27-c64eb71ae388",
      "name": "Prepare Markdown Binary"
    },
    {
      "parameters": {
        "name": "={{ $json.name || $json.researcher_profile?.researcher_name || 'Classification_Report' }}",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "1qH4jlOTGhnej7plawdaNAWqjSe4Ex5uO",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        2688,
        2864
      ],
      "id": "b139a620-a4b5-4e80-89f8-41a69ec99d2a",
      "name": "Upload file Markdown",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "HVpWOvlA9BuTQtEK",
          "name": "Google Drive (biotech3220)"
        }
      }
    }
  ],
  "pinData": {
    "When clicking ‚ÄòExecute workflow‚Äô": [
      {
        "json": {}
      }
    ],
    "Schedule Trigger": [
      {
        "json": {
          "timestamp": "2026-01-19T05:44:13.233+11:00",
          "Readable date": "January 19th 2026, 5:44:13 am",
          "Readable time": "5:44:13 am",
          "Day of week": "Monday",
          "Year": "2026",
          "Month": "January",
          "Day of month": "19",
          "Hour": "05",
          "Minute": "44",
          "Second": "13",
          "Timezone": "Australia/Melbourne (UTC+11:00)"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Fetch FATObjects": {
      "main": [
        [
          {
            "node": "Parse Neo4j Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Neo4j Response": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Embedding Vector": {
      "main": [
        [
          {
            "node": "Merge Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Embedding": {
      "main": [
        [
          {
            "node": "Prepare Vector Search GROUPS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          {
            "node": "Check Parse Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass 2: LLM Enrichment": {
      "main": [
        [
          {
            "node": "Parse LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Neo4j Write Query": {
      "main": [
        [
          {
            "node": "Write to Neo4j",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write to Neo4j": {
      "main": [
        [
          {
            "node": "Prepare Qdrant Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Qdrant": {
      "main": [
        [
          {
            "node": "Prepare PostgreSQL Classification Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Qdrant Payload": {
      "main": [
        [
          {
            "node": "Update Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Fetch FATObjects": {
      "main": [
        [
          {
            "node": "Fetch FATObjects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Status Update to Classifying": {
      "main": [
        [
          {
            "node": "Parse Status Update Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Status Update Response": {
      "main": [
        [
          {
            "node": "Fetch Embedding Vector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Status Update to Classifying": {
      "main": [
        [
          {
            "node": "Execute Status Update to Classifying",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Crosswalk Assessment Query": {
      "main": [
        [
          {
            "node": "Execute Crosswalk Assessment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Crosswalk Assessment": {
      "main": [
        [
          {
            "node": "Calculate Crosswalk Alignment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Crosswalk Alignment": {
      "main": [
        [
          {
            "node": "Prepare CRE Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Output": {
      "main": [
        [
          {
            "node": "JSON to HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare PostgreSQL Classification Log": {
      "main": [
        [
          {
            "node": "Store Crosswalk Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Crosswalk Metadata": {
      "main": [
        [
          {
            "node": "Prepare Classification Signals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ANZSRC Hierarchy Check": {
      "main": [
        [
          {
            "node": "Calculate Final Confidence & Assign Tiers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SYSTEM-2_CRE_Assessment": {
      "main": [
        [
          {
            "node": "Merge CRE Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge CRE Output": {
      "main": [
        [
          {
            "node": "ANZSRC Hierarchy Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare CRE Input": {
      "main": [
        [
          {
            "node": "SYSTEM-2_CRE_Assessment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Pass 2: LLM Enrichment",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Prepare FOS Vector Search": {
      "main": [
        [
          {
            "node": "Vector Search FOS (Qdrant)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse FOS Candidates": {
      "main": [
        [
          {
            "node": "Prepare Dual-Standard LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search FOS (Qdrant)": {
      "main": [
        [
          {
            "node": "Parse FOS Candidates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cohere Rerank": {
      "main": [
        [
          {
            "node": "Parse Cohere Rerank Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cohere Request": {
      "main": [
        [
          {
            "node": "Cohere Rerank",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Cohere Rerank Results": {
      "main": [
        [
          {
            "node": "Prepare FOS Vector Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search FIELDS": {
      "main": [
        [
          {
            "node": "Parse Vector Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Dual-Standard LLM Prompt": {
      "main": [
        [
          {
            "node": "Pass 2: LLM Enrichment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [],
        [
          {
            "node": "Check Data Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Data Quality": {
      "main": [
        [
          {
            "node": "Prepare Status Update to Classifying",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Parse Success": {
      "main": [
        [
          {
            "node": "Pass 2: LLM Enrichment",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Classification Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Failure Update (Neo4j)": {
      "main": [
        [
          {
            "node": "Execute Status Update to (Sparse Data)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Status Update to (Sparse Data)1": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classification Failed": {
      "main": [
        [
          {
            "node": "Prepare Failure Update (Neo4j)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Crosswalk Assessment Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Vector Search GROUPS": {
      "main": [
        [
          {
            "node": "Vector Search GROUPS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search GROUPS": {
      "main": [
        [
          {
            "node": "Parse Group Results & Prepare Cohere",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Group Results & Prepare Cohere": {
      "main": [
        [
          {
            "node": "Cohere Rerank Groups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cohere Rerank Groups": {
      "main": [
        [
          {
            "node": "Extract Matched Groups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Matched Groups": {
      "main": [
        [
          {
            "node": "Vector Search FIELDS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Vector Search Results": {
      "main": [
        [
          {
            "node": "Prepare Cohere Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Classification Signals": {
      "main": [
        [
          {
            "node": "Write Signals to Neo4j",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Signals to Neo4j": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON to HTML": {
      "main": [
        [
          {
            "node": "Generate Markdown Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare HTML as Binary File": {
      "main": [
        [
          {
            "node": "HTML to PDF(Gotenberg)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML to PDF(Gotenberg)": {
      "main": [
        [
          {
            "node": "Edit Binary Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Binary Metadata": {
      "main": [
        [
          {
            "node": "Upload file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Prepare Fetch FATObjects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Final Confidence & Assign Tiers": {
      "main": [
        [
          {
            "node": "Prepare Neo4j Write Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Markdown Report": {
      "main": [
        [
          {
            "node": "Prepare Markdown Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Markdown Binary": {
      "main": [
        [
          {
            "node": "Upload file Markdown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file Markdown": {
      "main": [
        [
          {
            "node": "Prepare HTML as Binary File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "32b7b740-865b-4147-90b1-3391bf3b6320",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bc0e623ae1bb3524870487de3c7fa60f3a571019006cc26dd79ca981250a48aa"
  },
  "id": "UPlGNbIBt9yXk9bb",
  "tags": [
    {
      "updatedAt": "2025-12-16T11:15:39.965Z",
      "createdAt": "2025-12-16T11:15:39.965Z",
      "id": "3qOz4Ic6lOIRKblO",
      "name": "Dual Standard"
    },
    {
      "updatedAt": "2025-12-18T01:54:55.218Z",
      "createdAt": "2025-12-18T01:54:55.218Z",
      "id": "XpmoqTfbBuwBUZCw",
      "name": "CRE"
    },
    {
      "updatedAt": "2025-12-18T01:45:03.480Z",
      "createdAt": "2025-12-18T01:45:03.480Z",
      "id": "zT0OLWLVBAVEOSHg",
      "name": "Crosswalk"
    }
  ]
}