{
  "name": "OBJECT-2_v2 GEN 5 Workflow (Object Fabrication/Re-Fabrication)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "id": "40c2b5c0-11ee-4a84-8662-296127e77763",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        32,
        1616
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "object-2-fabricate",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "09937e90-6068-42c3-be5c-bda1f11b378c",
      "name": "Webhook Trigger (Refab)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        464,
        32
      ],
      "webhookId": "object-2-fabricate"
    },
    {
      "parameters": {
        "jsCode": "// Merge Inputs - Entry point normalization\n// Detects mode from input source and sets execution context\n\nconst inputData = $input.first().json;\n\n// Webhook wraps payload in 'body', Schedule Trigger doesn't\nconst payload = inputData.body || inputData;\n\nlet executionContext;\n\nif (payload.mode === 'refabrication') {\n  // From Webhook - refabrication mode\n  executionContext = {\n    mode: 'refabrication',\n    fat_asset_id: payload.asset_id,\n    thin_asset_id: payload.asset_id.replace(/^fat:/, 'thin:'),\n    new_version: payload.new_version || 'v2.0',\n    previous_version: payload.previous_version || 'v1.0',\n    refabrication_reason: payload.refabrication_reason || 'change_detected',\n    changed_fields: payload.changed_fields || [],\n    source_queue_entry_id: payload.source_queue_entry_id || null,\n    requires_fresh_scrape: payload.requires_fresh_scrape || false\n  };\n} else {\n  // From Schedule Trigger - normal polling mode\n  executionContext = {\n    mode: 'normal',\n    fat_asset_id: null,\n    thin_asset_id: null,\n    new_version: 'v1.0',\n    previous_version: null,\n    refabrication_reason: null,\n    changed_fields: [],\n    source_queue_entry_id: null,\n    requires_fresh_scrape: false\n  };\n}\n\nreturn [{ json: executionContext }];"
      },
      "id": "77598043-6afe-40a2-8eca-49533a5406f8",
      "name": "Merge Inputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        736,
        -16
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.mode }}",
                    "rightValue": "normal",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "86337ad1-a352-442b-8578-730a23993938"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "normal"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.mode }}",
                    "rightValue": "refabrication",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "63cb6ba9-fb33-4ce5-8bd4-0f9968056785"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "refabrication"
            }
          ]
        },
        "options": {}
      },
      "id": "ead9412a-7ded-4c97-8d3f-c12a84c3d756",
      "name": "Route by Mode",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        960,
        -16
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Fetch ThinObject - Refabrication Mode\n// Fetches specific ThinObject by asset_id for re-fabrication\n\nconst executionContext = $input.first().json;\n\nreturn [{\n  json: {\n    execution_context: executionContext,\n    neo4j_payload: {\n      statement: `\n        MATCH (thin:ThinObject {asset_id: $thin_asset_id})\n        WHERE thin.object_type = $object_type\n        RETURN {\n          object_id: thin.asset_id,\n          name: thin.name,\n          orcid: thin.orcid,\n          email: thin.email,\n          institution: thin.institution,\n          orcid_data: thin.orcid_data,\n          scopus_data: thin.scopus_data,\n          scholar_data: thin.scholar_data,\n          university_data: thin.university_data,\n          patents_data: thin.patents_data,\n          source_metadata: thin.source_metadata,\n          created_at: thin.created_at\n        } as thin_object\n        LIMIT 1\n      `,\n      parameters: {\n        thin_asset_id: executionContext.thin_asset_id,\n        object_type: \"researcher\"\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        144
      ],
      "id": "cc7e736a-6534-4575-af2d-1628deccfba7",
      "name": "Prepare Fetch ThinObject (Refab)"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://8b9cbf46.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1440,
        144
      ],
      "id": "b6269d67-9808-4470-a5a8-3da9b096f2e7",
      "name": "Fetch ThinObject (Refab)",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Neo4j Response - Refabrication Mode\n// Parses response for specific ThinObject, sets refab status\n\nconst response = $input.first().json;\nconst executionContext = $('Prepare Fetch ThinObject (Refab)').first().json.execution_context;\n\n// Handle empty results or errors\nif (!response.data || !response.data.values || response.data.values.length === 0) {\n  return [{\n    json: {\n      execution_context: executionContext,\n      neo4j_payload: null,\n      thin_objects: [],\n      skipped: true,\n      message: `ThinObject not found: ${executionContext.thin_asset_id}`\n    }\n  }];\n}\n\n// Parse Neo4j response\nconst thinObjects = response.data.values.map(row => row[0]);\nconst objectIds = thinObjects.map(obj => obj.object_id);\n\nreturn [{\n  json: {\n    execution_context: executionContext,\n    neo4j_payload: {\n      statement: `\n        UNWIND $object_ids AS object_id\n        MATCH (thin:ThinObject {asset_id: object_id})\n        SET thin.status = $new_status\n        SET thin.refabrication_started_at = timestamp()\n        SET thin.refabrication_version = $new_version\n        RETURN thin.asset_id as updated_id\n      `,\n      parameters: {\n        object_ids: objectIds,\n        new_status: \"refabricating\",\n        new_version: executionContext.new_version\n      }\n    },\n    thin_objects: thinObjects\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        144
      ],
      "id": "bea837ed-6279-4f20-9110-e370f1c87576",
      "name": "Prepare Set Status (Refab)"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://8b9cbf46.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1920,
        144
      ],
      "id": "b2732ff3-6363-4ede-8e90-9a89250cbac6",
      "name": "Set Status: Refabricating",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Split ThinObjects - Normal Mode\n// Gets thin_objects and execution_context from Prepare node\n\nconst prepareData = $('Prepare Set Status Fabricating').first().json;\nconst thinObjects = prepareData.thin_objects;\nconst executionContext = prepareData.execution_context;\n\n// Attach execution context to each thin object\nreturn thinObjects.map(obj => ({ \n  json: {\n    ...obj,\n    execution_context: executionContext\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        -160
      ],
      "id": "32b4fa9b-6fd3-444e-b6c9-4acc6f280437",
      "name": "Split ThinObjects"
    },
    {
      "parameters": {
        "jsCode": "// Split ThinObjects - Refab Mode\n// Gets thin_objects and execution_context from Prepare node\n\nconst prepareData = $('Prepare Set Status (Refab)').first().json;\nconst thinObjects = prepareData.thin_objects;\nconst executionContext = prepareData.execution_context;\n\n// Attach execution context to each thin object\nreturn thinObjects.map(obj => ({ \n  json: {\n    ...obj,\n    execution_context: executionContext\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        144
      ],
      "id": "73a9fd3a-aebf-46c0-94c5-ca7f42406396",
      "name": "Split ThinObjects (Refab)"
    },
    {
      "parameters": {
        "jsCode": "// Check Execution Mode for Response\n// Routes to appropriate completion handling\n\nconst executionContext = $('Prepare PostgreSQL Payload').first().json.execution_context || {};\nconst isRefabrication = executionContext.mode === 'refabrication';\n\nreturn [{\n  json: {\n    is_refabrication: isRefabrication,\n    execution_context: executionContext\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        848
      ],
      "id": "57acb24f-284b-4216-8d03-5ef5a3382791",
      "name": "Check Mode for Response"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.execution_context.mode }}",
                    "rightValue": "refabrication",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "54e2a0a1-d836-49bb-9cbf-501ab24f8c5e"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "refab_complete"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "0f7a526c-bf9d-4a75-ad17-f1097a2f7886",
      "name": "Route Completion",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1888,
        848
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  \"success\": true,\n  \"mode\": \"refabrication\",\n  \"asset_id\": $('Merge Embedding').first().json.asset_id,\n  \"version\": $('Merge Embedding').first().json.version,\n  \"previous_version\": $('Merge Embedding').first().json.provenance.previous_version,\n  \"status\": \"fabricated\",\n  \"fabricated_at\": $('Merge Embedding').first().json.provenance.fabricated_at,\n  \"message\": \"Refabrication completed successfully\"\n} }}",
        "options": {}
      },
      "id": "24fabc42-9bb9-46dd-ac1e-f459758a8de6",
      "name": "Respond to Webhook (Refab)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2176,
        736
      ]
    },
    {
      "parameters": {},
      "id": "3b85234c-a4a0-4738-98ec-471d6c41d154",
      "name": "Loop Back (Normal)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        2128,
        960
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "id": "b59c6417-cd5f-4a57-bd9d-814bc5c18189",
      "name": "Schedule Trigger1",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        480,
        -176
      ]
    },
    {
      "parameters": {
        "model": "openai/gpt-4o",
        "options": {
          "maxTokens": 3000,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        592,
        656
      ],
      "id": "7596f7ee-c179-4ead-8fb7-523c45268b68",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Prepare LLM Prompt - Definition Card v3.2 Compliant\n// MODIFIED: Uses enrichment prompt from researcher_instance_spec_v2_2.md Section 10\n// MODIFIED: Outputs raw_evidence + enriched_context structure for OBJECT-3\n\nconst unifiedObject = $input.first().json;\nconst executionContext = unifiedObject.execution_context;\n\nconst name = unifiedObject.name;\nconst institution = unifiedObject.institution || 'Unknown';\n\n// Format metrics\nconst metrics = unifiedObject.metrics || {};\nconst hIndex = metrics.h_index || 0;\nconst totalCitations = metrics.total_citations || 0;\nconst publicationCount = metrics.publication_count || 0;\nconst patentCount = metrics.patent_count || 0;\n\n// ===== NEW: Format publications WITH abstracts (top 15) =====\nconst publications = unifiedObject.publications || [];\nconst publicationsForPrompt = publications\n  .slice(0, 15)\n  .map(pub => ({\n    title: pub.title || '',\n    abstract: (pub.abstract || '').substring(0, 200),\n    keywords: pub.keywords || [],\n    year: pub.year || null,\n    citations: pub.citations || 0\n  }));\n\n// ===== NEW: Format grants =====\nconst grants = unifiedObject.grants || [];\nconst grantsForPrompt = grants.map(grant => ({\n  title: grant.title || '',\n  funder: grant.funder || '',\n  amount: grant.amount || null,\n  dates: grant.dates || ''\n}));\n\n// ===== NEW: Get biography (complete, not summarised) =====\nconst biography = unifiedObject.biography || '';\n\n// ===== NEW: Get research_interests (separate from keywords) =====\nconst researchInterests = unifiedObject.research_interests || [];\n\n// Format keywords (for additional context)\nconst keywords = (unifiedObject.keywords || []).slice(0, 20);\nconst keywordsText = keywords.length > 0 ? keywords.join(', ') : 'None available';\n\n// Format patents\nconst patents = unifiedObject.patents || [];\nconst patentsForPrompt = patents.slice(0, 10).map(pat => ({\n  title: pat.title || '',\n  year: pat.year || null\n}));\n\n// ===== NEW: Complete prompt per researcher_instance_spec_v2_2.md Section 10 =====\nconst prompt = `You are enriching a researcher profile for a capability intelligence system.\n\nINPUT DATA:\n- Name: ${name}\n- Institution: ${institution}\n- H-index: ${hIndex}\n- Total Citations: ${totalCitations}\n- Publication Count: ${publicationCount}\n- Patent Count: ${patentCount}\n\nPublications (Top 15 with abstracts):\n${JSON.stringify(publicationsForPrompt, null, 2)}\n\nBio:\n${biography || 'Not available'}\n\nGrants:\n${JSON.stringify(grantsForPrompt, null, 2)}\n\nResearch Interests (from source):\n${JSON.stringify(researchInterests)}\n\nPatents:\n${JSON.stringify(patentsForPrompt, null, 2)}\n\nAdditional Keywords:\n${keywordsText}\n\nTASK: Extract and structure researcher capabilities.\n\nProvide:\n\n1. **Career Stage** (critical for classification depth):\n   - early-career: < 5 years post-PhD, < 20 publications, h-index < 10\n   - mid-career: 5-15 years post-PhD, 20-80 publications, h-index 10-25\n   - senior: > 15 years post-PhD OR > 80 publications OR h-index > 25\n   - emeritus: retired but still active in research\n\n2. **Research Domains** (3-5 high-level fields):\n   - e.g., \"Marine Biotechnology\", \"Enzyme Engineering\", \"Food Science\"\n\n3. **Core Methodologies** (5-10 specific techniques):\n   - e.g., \"Lipase immobilisation\", \"Supercritical CO2 extraction\", \"HPLC analysis\"\n\n4. **Research Themes** (3-5 recurring topics across publications):\n   - e.g., \"Omega-3 enrichment\", \"Sustainable bioprocessing\", \"Functional foods\"\n\n5. **Equipment Expertise** (if identifiable from publications/grants):\n   - e.g., \"Mass spectrometry\", \"Bioreactors\", \"NMR spectroscopy\"\n\n6. **Collaboration Indicators**:\n   - Industry partnerships (if mentioned in grants/bio)\n   - International scope (if evident)\n\n7. **Achievement Indicators**:\n   - Research impact level: Emerging / Established / Leading\n   - Collaboration breadth: Local / National / International\n   - Funding track record: Minimal / Moderate / Extensive\n\nOUTPUT FORMAT: JSON with TWO required sections - raw_evidence (preserved from input) and enriched_context (your analysis).\n\n{\n  \"raw_evidence\": {\n    \"publications\": [\n      {\"title\": \"Publication title\", \"abstract\": \"First 200 chars of abstract...\", \"keywords\": [\"keyword1\", \"keyword2\"]}\n    ],\n    \"grants\": [\n      {\"title\": \"Grant title\", \"funder\": \"Funder name\", \"amount\": 500000, \"dates\": \"2022-2025\"}\n    ],\n    \"biography\": \"Complete biography text - preserve exactly as provided, DO NOT summarise\",\n    \"research_interests\": [\"Interest 1\", \"Interest 2\"]\n  },\n  \"enriched_context\": {\n    \"career_stage\": \"early-career | mid-career | senior | emeritus\",\n    \"career_stage_evidence\": \"Brief explanation of career stage assessment\",\n    \"research_domains\": [\"Domain 1\", \"Domain 2\", \"Domain 3\"],\n    \"methodologies\": [\"Method 1\", \"Method 2\", \"Method 3\"],\n    \"themes\": [\"Theme 1\", \"Theme 2\", \"Theme 3\"],\n    \"keywords\": [\"Extracted keyword 1\", \"Extracted keyword 2\"]\n  },\n  \"equipment_expertise\": [\"Equipment 1\", \"Equipment 2\"],\n  \"collaboration_indicators\": {\n    \"industry_partners\": [\"Company 1\"],\n    \"international_scope\": \"Yes/No with brief note\"\n  },\n  \"achievement_indicators\": {\n    \"research_impact\": \"Established\",\n    \"collaboration_breadth\": \"International\",\n    \"funding_track_record\": \"Extensive\"\n  }\n}\n\nCRITICAL RULES:\n1. The raw_evidence section MUST preserve input data exactly - copy publications, grants, biography, research_interests from the input. DO NOT summarise the biography.\n2. Include top 10-15 publications with titles, abstracts (first 200 chars), and keywords in raw_evidence.\n3. Include ALL grants with full details in raw_evidence.\n4. Preserve the complete biography text in raw_evidence.\n5. The enriched_context section contains YOUR analysis and extracted insights.\n6. Respond ONLY with valid JSON. Do not include any text outside the JSON structure.\n7. Start your response with { and end with }.`;\n\nreturn [{\n  json: {\n    prompt: prompt,\n    object_id: unifiedObject.object_id,\n    unified_data: unifiedObject,\n    execution_context: executionContext\n  }\n}];"
      },
      "id": "046fcd0c-1ced-4f9d-aada-1d104554aef1",
      "name": "Prepare LLM Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        352,
        448
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse LLM Response - Definition Card v3.2 Compliant\n// MODIFIED: Parses new raw_evidence + enriched_context structure\n// MODIFIED: Falls back gracefully for old format or parse errors\n// MODIFIED: More robust JSON cleaning for LLM output\n\n// Get LLM response from direct input\nconst llmResponse = $input.first().json.text;\n\n// Get unified_data and execution_context via node reference\nconst preparedData = $('Prepare LLM Prompt').first().json;\nconst unifiedObject = preparedData.unified_data;\nconst objectId = preparedData.object_id;\nconst executionContext = preparedData.execution_context;\n\n// Clean and parse - remove markdown code blocks if present\nlet cleanedResponse = llmResponse\n  .replace(/```json\\s*/g, '')\n  .replace(/```\\s*/g, '')\n  .trim();\n\n// Sometimes LLM adds text before/after JSON - try to extract JSON object\nconst jsonMatch = cleanedResponse.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  cleanedResponse = jsonMatch[0];\n}\n\n// ===== Fix common LLM JSON errors =====\ncleanedResponse = cleanedResponse\n  .replace(/,\\s*\\]/g, ']')       // Remove trailing comma before ]\n  .replace(/,\\s*\\}/g, '}')       // Remove trailing comma before }\n  .replace(/\\n/g, ' ')           // Replace newlines with spaces\n  .replace(/\\r/g, '')            // Remove carriage returns\n  .replace(/\\t/g, ' ')           // Replace tabs with spaces\n  .replace(/\\s+/g, ' ');         // Collapse multiple spaces\n\nlet enrichmentData;\nlet parseError = null;\n\ntry {\n  enrichmentData = JSON.parse(cleanedResponse);\n} catch (e) {\n  parseError = e.message;\n  \n  // Second attempt - even more aggressive cleaning\n  try {\n    let aggressiveCleaned = cleanedResponse\n      .replace(/[\\x00-\\x1F\\x7F]/g, '')  // Remove control characters\n      .replace(/\\\\n/g, ' ')              // Replace escaped newlines\n      .replace(/\\\\t/g, ' ')              // Replace escaped tabs\n      .replace(/\\\\/g, '\\\\\\\\');           // Escape backslashes\n    \n    enrichmentData = JSON.parse(aggressiveCleaned);\n    parseError = null;\n    console.log('JSON parse succeeded on second attempt');\n  } catch (e2) {\n    parseError = `First: ${e.message}; Second: ${e2.message}`;\n    enrichmentData = null;\n  }\n}\n\n// ===== Validate and normalize to required structure =====\nfunction normalizeEnrichmentData(parsed, unified, error) {\n  \n  // If parse failed completely, build from unified data\n  if (!parsed) {\n    return {\n      raw_evidence: {\n        publications: (unified.publications || []).slice(0, 15).map(p => ({\n          title: p.title || '',\n          abstract: (p.abstract || '').substring(0, 500),\n          keywords: p.keywords || []\n        })),\n        grants: (unified.grants || []).map(g => ({\n          title: g.title || '',\n          funder: g.funder || '',\n          amount: g.amount || null,\n          dates: g.dates || ''\n        })),\n        biography: unified.biography || '',\n        research_interests: unified.research_interests || []\n      },\n      enriched_context: {\n        career_stage: 'unknown',\n        career_stage_evidence: `LLM parse error: ${error}`,\n        research_domains: [],\n        methodologies: [],\n        themes: [],\n        keywords: []\n      },\n      equipment_expertise: [],\n      collaboration_indicators: {\n        industry_partners: [],\n        international_scope: 'Unknown'\n      },\n      achievement_indicators: {\n        research_impact: 'Unknown',\n        collaboration_breadth: 'Unknown',\n        funding_track_record: 'Unknown'\n      },\n      enrichment_error: error\n    };\n  }\n  \n  // Check if LLM returned NEW format (has raw_evidence and enriched_context)\n  const hasNewFormat = parsed.raw_evidence && parsed.enriched_context;\n  \n  if (hasNewFormat) {\n    // ===== NEW FORMAT: Validate and fill gaps =====\n    return {\n      raw_evidence: {\n        publications: (parsed.raw_evidence.publications || []).slice(0, 15).map(p => ({\n          title: p.title || '',\n          abstract: (p.abstract || '').substring(0, 500),\n          keywords: p.keywords || []\n        })),\n        grants: parsed.raw_evidence.grants || unified.grants || [],\n        biography: parsed.raw_evidence.biography || unified.biography || '',\n        research_interests: parsed.raw_evidence.research_interests || unified.research_interests || []\n      },\n      enriched_context: {\n        career_stage: parsed.enriched_context.career_stage || 'unknown',\n        career_stage_evidence: parsed.enriched_context.career_stage_evidence || '',\n        research_domains: parsed.enriched_context.research_domains || [],\n        methodologies: parsed.enriched_context.methodologies || [],\n        themes: parsed.enriched_context.themes || parsed.enriched_context.research_themes || [],\n        keywords: parsed.enriched_context.keywords || []\n      },\n      equipment_expertise: parsed.equipment_expertise || [],\n      collaboration_indicators: parsed.collaboration_indicators || {\n        industry_partners: [],\n        international_scope: 'Unknown'\n      },\n      achievement_indicators: parsed.achievement_indicators || {\n        research_impact: 'Unknown',\n        collaboration_breadth: 'Unknown',\n        funding_track_record: 'Unknown'\n      }\n    };\n  } else {\n    // ===== OLD FORMAT: Reshape to new structure =====\n    return {\n      raw_evidence: {\n        publications: (unified.publications || []).slice(0, 15).map(p => ({\n          title: p.title || '',\n          abstract: (p.abstract || '').substring(0, 500),\n          keywords: p.keywords || []\n        })),\n        grants: (unified.grants || []).map(g => ({\n          title: g.title || '',\n          funder: g.funder || '',\n          amount: g.amount || null,\n          dates: g.dates || ''\n        })),\n        biography: unified.biography || '',\n        research_interests: unified.research_interests || []\n      },\n      enriched_context: {\n        career_stage: parsed.career_stage || 'unknown',\n        career_stage_evidence: parsed.career_stage_evidence || '',\n        research_domains: parsed.research_domains || [],\n        methodologies: parsed.methodologies || [],\n        themes: parsed.research_themes || parsed.themes || [],\n        keywords: parsed.keywords || []\n      },\n      equipment_expertise: parsed.equipment_expertise || [],\n      collaboration_indicators: parsed.collaboration_indicators || {\n        industry_partners: [],\n        international_scope: 'Unknown'\n      },\n      achievement_indicators: parsed.achievement_indicators || {\n        research_impact: (parsed.achievement_indicators || {}).research_impact || 'Unknown',\n        collaboration_breadth: (parsed.achievement_indicators || {}).collaboration_breadth || 'Unknown',\n        funding_track_record: (parsed.achievement_indicators || {}).funding_track_record || 'Unknown'\n      },\n      _reshaped_from_old_format: true\n    };\n  }\n}\n\n// Normalize the enrichment data\nconst normalizedEnrichment = normalizeEnrichmentData(enrichmentData, unifiedObject, parseError);\n\n// Validate raw_evidence completeness\nconst rawEvidence = normalizedEnrichment.raw_evidence;\nconst validationFlags = [];\n\nif (!rawEvidence.publications || rawEvidence.publications.length === 0) {\n  validationFlags.push('missing_publications_in_raw_evidence');\n}\nif (!rawEvidence.grants || rawEvidence.grants.length === 0) {\n  validationFlags.push('missing_grants_in_raw_evidence');\n}\nif (!rawEvidence.biography) {\n  validationFlags.push('missing_biography_in_raw_evidence');\n}\nif (!rawEvidence.research_interests || rawEvidence.research_interests.length === 0) {\n  validationFlags.push('missing_research_interests_in_raw_evidence');\n}\n\nnormalizedEnrichment._validation_flags = validationFlags;\n\n// Build final enriched object\nconst enrichedObject = {\n  ...unifiedObject,\n  object_id: objectId,\n  enrichment: normalizedEnrichment,\n  enriched_at: new Date().toISOString(),\n  execution_context: executionContext\n};\n\nconsole.log(`Parse LLM complete: career_stage=${normalizedEnrichment.enriched_context.career_stage}, domains=${normalizedEnrichment.enriched_context.research_domains.length}`);\n\nreturn [{ json: enrichedObject }];"
      },
      "id": "0f160440-afcf-45e4-aa1d-7b5a1972449b",
      "name": "Parse LLM Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        880,
        448
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://8b9cbf46.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1440,
        -160
      ],
      "id": "087cd9ac-d731-491c-8cdb-f2f74d63a158",
      "name": "Fetch ThinObjects",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Neo4j Response - Normal Mode\n// Parses response AND prepares status update query\n\nconst response = $input.first().json;\nconst executionContext = $('Prepare Fetch ThinObjects').first().json.execution_context;\n\n// Handle empty results or errors\nif (!response.data || !response.data.values || response.data.values.length === 0) {\n  return [{\n    json: {\n      execution_context: executionContext,\n      neo4j_payload: null,\n      thin_objects: [],\n      skipped: true,\n      message: \"No ThinObjects to process\"\n    }\n  }];\n}\n\n// Parse Neo4j response: data.values is array of [thin_object] rows\nconst thinObjects = response.data.values.map(row => row[0]);\n\n// Extract object_ids for the status update\nconst objectIds = thinObjects.map(obj => obj.object_id);\n\nreturn [{\n  json: {\n    execution_context: executionContext,\n    neo4j_payload: {\n      statement: `\n        UNWIND $object_ids AS object_id\n        MATCH (thin:ThinObject {asset_id: object_id})\n        SET thin.status = $new_status\n        SET thin.fabricating_started_at = timestamp()\n        RETURN thin.asset_id as updated_id\n      `,\n      parameters: {\n        object_ids: objectIds,\n        new_status: \"enriching\"\n      }\n    },\n    thin_objects: thinObjects\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        -160
      ],
      "id": "f5b429f5-5897-458f-bc59-312be523aa67",
      "name": "Prepare Set Status Fabricating"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://8b9cbf46.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1920,
        -160
      ],
      "id": "8938a6d6-27f6-4f61-88e3-523d8776b8fb",
      "name": "Set Status: Fabricating",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "bb08ddce-9808-4704-bac9-596ae12d6741",
      "name": "Loop Through Objects",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2432,
        -16
      ]
    },
    {
      "parameters": {
        "functionCode": "// Pass 1: Structural Unification\n// Merges data from multiple sources and creates unified researcher profile\n// UPDATED: Uses direct fields from OBJECT-1 v3.x with JSON fallback\n\n// ============================================================\n// SECTION 1: Get input data\n// ============================================================\n\nconst thinObject = $input.first().json;\nconst executionContext = thinObject.execution_context;\n\n// ============================================================\n// SECTION 2: Helper functions\n// ============================================================\n\n// Parse JSON strings safely\nconst parseIfString = (value, defaultVal) => {\n  if (!value) return defaultVal;\n  if (typeof value === 'string') {\n    try { return JSON.parse(value); } catch (e) { return defaultVal; }\n  }\n  return value;\n};\n\n// Title similarity for deduplication\nfunction titleSimilarity(title1, title2) {\n  if (!title1 || !title2) return 0;\n  const words1 = new Set(title1.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n  const words2 = new Set(title2.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n  if (words1.size === 0 || words2.size === 0) return 0;\n  const intersection = new Set([...words1].filter(x => words2.has(x)));\n  const union = new Set([...words1, ...words2]);\n  return intersection.size / union.size;\n}\n\n// ============================================================\n// SECTION 3: Extract direct fields (OBJECT-1 v3.x format)\n// ============================================================\n\nconst biography = thinObject.biography || '';\nconst research_interests = thinObject.research_interests || [];\nconst current_projects = thinObject.current_projects || [];\nconst expertise_keywords = thinObject.expertise_keywords || [];\nconst directCollaborators = thinObject.collaborators || [];\nconst directKeywords = thinObject.keywords || [];\nconst directPublications = parseIfString(thinObject.publications, []);\nconst directPatents = parseIfString(thinObject.patents, []);\nconst directAffiliations = parseIfString(thinObject.affiliations, []);\nconst directGrants = parseIfString(thinObject.grants, []);\nconst directMetrics = parseIfString(thinObject.metrics, {});\n\n// ============================================================\n// SECTION 4: Extract legacy JSON fields (backward compatibility)\n// ============================================================\n\nconst orcidData = parseIfString(thinObject.orcid_data, {});\nconst scopusData = parseIfString(thinObject.scopus_data, {});\nconst scholarData = parseIfString(thinObject.scholar_data, {});\nconst universityData = parseIfString(thinObject.university_data, {});\nconst patentsData = parseIfString(thinObject.patents_data, {});\n\n// Source metadata for provenance\nconst sourceMetadata = parseIfString(thinObject.source_metadata, {\n  sources_scraped: [],\n  scrape_timestamps: {},\n  field_hashes: {}\n});\n\n// ============================================================\n// SECTION 5: Build unified object\n// ============================================================\n\nconst unified = {\n  object_id: thinObject.object_id,\n  name: thinObject.name,\n  orcid: thinObject.orcid || null,\n  email: thinObject.email || null,\n  institution: thinObject.institution || null,\n  \n  // Raw evidence fields (CRITICAL for OBJECT-3 classification)\n  biography: biography || universityData.biography || '',\n  research_interests: research_interests.length > 0 ? research_interests : (universityData.research_interests || []),\n  current_projects: current_projects.length > 0 ? current_projects : (universityData.current_projects || []),\n  expertise_keywords: expertise_keywords.length > 0 ? expertise_keywords : [],\n  grants: directGrants.length > 0 ? directGrants : [],\n  \n  // Collections (populated below)\n  publications: [],\n  collaborators: [],\n  keywords: [],\n  affiliations: [],\n  patents: [],\n  \n  // Metrics (populated below)\n  metrics: {},\n  \n  // Quality flags\n  data_quality_flags: thinObject.data_quality_flags || [],\n  data_completeness: thinObject.data_completeness || 0,\n  source_metadata: sourceMetadata,\n  execution_context: executionContext\n};\n\n// ============================================================\n// SECTION 6: Merge publications\n// ============================================================\n\nif (directPublications.length > 0) {\n  // Use direct publications from OBJECT-1\n  unified.publications = directPublications;\n} else {\n  // Legacy: merge from orcid, scopus, scholar JSON fields\n  const publicationsMap = new Map();\n  \n  // Add Scopus publications\n  (scopusData.publications || []).forEach(pub => {\n    const doi = pub.doi;\n    const key = doi || `scopus_${(pub.title || '').toLowerCase().substring(0, 50)}`;\n    if (pub.title && !publicationsMap.has(key)) {\n      publicationsMap.set(key, {\n        title: pub.title,\n        doi: doi,\n        year: pub.year,\n        citations: pub.citations || 0,\n        authors: pub.authors || [],\n        abstract: pub.abstract || '',\n        keywords: pub.keywords || [],\n        source: 'scopus'\n      });\n    }\n  });\n  \n  // Add ORCID publications\n  (orcidData.publications || []).forEach(pub => {\n    const doi = pub.doi;\n    const key = doi || `orcid_${(pub.title || '').toLowerCase().substring(0, 50)}`;\n    \n    if (doi && publicationsMap.has(doi)) {\n      // Merge with existing - update citations if higher\n      const existing = publicationsMap.get(doi);\n      existing.citations = Math.max(existing.citations || 0, pub.citations || 0);\n    } else if (!publicationsMap.has(key)) {\n      // Check for title duplicates\n      let isDuplicate = false;\n      for (const [existingKey, existingPub] of publicationsMap.entries()) {\n        if (titleSimilarity(pub.title, existingPub.title) > 0.85) {\n          isDuplicate = true;\n          break;\n        }\n      }\n      \n      if (!isDuplicate && pub.title) {\n        publicationsMap.set(key, {\n          title: pub.title,\n          doi: doi,\n          year: pub.year,\n          citations: pub.citations || 0,\n          type: pub.type,\n          source: 'orcid'\n        });\n      }\n    }\n  });\n  \n  // Add Scholar publications\n  (scholarData.publications || scholarData.articles || []).forEach(pub => {\n    const title = pub.title || '';\n    const doi = pub.doi;\n    \n    if (doi && publicationsMap.has(doi)) {\n      // Merge citations (Scholar often has higher counts)\n      const existing = publicationsMap.get(doi);\n      existing.citations = Math.max(existing.citations || 0, pub.citations || pub.cited_by || 0);\n    } else {\n      // Check for title duplicates\n      let isDuplicate = false;\n      for (const [existingKey, existingPub] of publicationsMap.entries()) {\n        if (titleSimilarity(title, existingPub.title) > 0.85) {\n          isDuplicate = true;\n          existingPub.citations = Math.max(existingPub.citations || 0, pub.citations || pub.cited_by || 0);\n          break;\n        }\n      }\n      \n      if (!isDuplicate && title) {\n        const key = doi || `scholar_${title.toLowerCase().substring(0, 50)}`;\n        publicationsMap.set(key, {\n          title: title,\n          doi: doi,\n          year: pub.year,\n          citations: pub.citations || pub.cited_by || 0,\n          source: 'scholar'\n        });\n      }\n    }\n  });\n  \n  unified.publications = Array.from(publicationsMap.values());\n}\n\n// ============================================================\n// SECTION 7: Merge collaborators\n// ============================================================\n\nif (directCollaborators.length > 0) {\n  unified.collaborators = directCollaborators;\n} else {\n  const collaboratorsSet = new Set();\n  const researcherNameLower = (thinObject.name || '').toLowerCase();\n  \n  // From publications\n  unified.publications.forEach(pub => {\n    (pub.authors || []).forEach(author => {\n      const authorName = (typeof author === 'string' ? author : author.name || '').trim();\n      if (authorName && authorName.toLowerCase() !== researcherNameLower) {\n        collaboratorsSet.add(authorName);\n      }\n    });\n  });\n  \n  // From Scholar co-authors\n  (scholarData.co_authors || []).forEach(coauthor => {\n    const name = (typeof coauthor === 'string' ? coauthor : coauthor.name || '').trim();\n    if (name && name.toLowerCase() !== researcherNameLower) {\n      collaboratorsSet.add(name);\n    }\n  });\n  \n  unified.collaborators = Array.from(collaboratorsSet);\n}\n\n// ============================================================\n// SECTION 8: Merge keywords\n// ============================================================\n\nif (directKeywords.length > 0) {\n  unified.keywords = directKeywords;\n} else {\n  const keywordsSet = new Set();\n  \n  // From university/Deakin data\n  (universityData.research_interests || []).forEach(kw => {\n    if (kw) keywordsSet.add(kw.toLowerCase().trim());\n  });\n  \n  // From ORCID\n  (orcidData.keywords || []).forEach(kw => {\n    if (kw) keywordsSet.add(kw.toLowerCase().trim());\n  });\n  \n  // From Scholar interests\n  (scholarData.interests || []).forEach(kw => {\n    if (kw) keywordsSet.add(kw.toLowerCase().trim());\n  });\n  \n  // From Scopus subject areas\n  (scopusData.subject_areas || []).forEach(area => {\n    const areaName = area.area || area;\n    if (areaName) keywordsSet.add(areaName.toLowerCase().trim());\n  });\n  \n  // From publication keywords\n  unified.publications.forEach(pub => {\n    (pub.keywords || []).forEach(kw => {\n      if (kw) keywordsSet.add(kw.toLowerCase().trim());\n    });\n  });\n  \n  unified.keywords = Array.from(keywordsSet);\n}\n\n// ============================================================\n// SECTION 9: Merge affiliations\n// ============================================================\n\nif (directAffiliations.length > 0) {\n  unified.affiliations = directAffiliations;\n} else {\n  const affiliations = [];\n  \n  // From ORCID employment\n  (orcidData.employment || []).forEach(emp => {\n    const orgName = typeof emp.organization === 'string' \n      ? emp.organization \n      : emp.organization?.name;\n    \n    if (orgName) {\n      affiliations.push({\n        institution: orgName,\n        department: emp.department || null,\n        role: emp.role || emp['role-title'] || null,\n        start_date: emp.start_year || emp.start_date || null,\n        end_date: emp.end_year || emp.end_date || null,\n        current: !emp.end_year && !emp.end_date,\n        source: 'orcid'\n      });\n    }\n  });\n  \n  // From university data\n  if (universityData.department || universityData.position) {\n    affiliations.push({\n      institution: thinObject.institution || 'Unknown',\n      department: universityData.department || null,\n      position: universityData.position || null,\n      current: true,\n      source: 'university'\n    });\n  }\n  \n  // Add current institution if not already present\n  if (thinObject.institution) {\n    const alreadyHasCurrent = affiliations.some(a => \n      a.institution === thinObject.institution && a.current\n    );\n    if (!alreadyHasCurrent) {\n      affiliations.push({\n        institution: thinObject.institution,\n        current: true,\n        source: 'current'\n      });\n    }\n  }\n  \n  unified.affiliations = affiliations;\n}\n\n// ============================================================\n// SECTION 10: Merge patents\n// ============================================================\n\nif (directPatents.length > 0) {\n  unified.patents = directPatents;\n} else {\n  unified.patents = patentsData.patents || [];\n}\n\n// ============================================================\n// SECTION 11: Calculate metrics\n// ============================================================\n\nif (Object.keys(directMetrics).length > 0 && directMetrics.h_index) {\n  unified.metrics = directMetrics;\n} else {\n  unified.metrics = {\n    h_index: Math.max(\n      scopusData.h_index || 0,\n      scholarData.h_index || scholarData.cited_by?.h_index || 0,\n      directMetrics.h_index || 0\n    ),\n    total_citations: Math.max(\n      scopusData.citation_count || scopusData.citations || scopusData.cited_by_count || 0,\n      scholarData.citations || scholarData.cited_by?.all || 0,\n      directMetrics.total_citations || 0\n    ),\n    publication_count: Math.max(\n      scopusData.document_count || 0,\n      unified.publications.length,\n      directMetrics.publication_count || 0\n    ),\n    collaborator_count: unified.collaborators.length,\n    patent_count: directMetrics.patent_count || patentsData.patent_count || unified.patents.length || 0,\n    grant_count: unified.grants.length,\n    research_interest_count: unified.research_interests.length,\n    current_project_count: unified.current_projects.length\n  };\n}\n\n// ============================================================\n// SECTION 12: Data quality flags\n// ============================================================\n\nif (unified.data_quality_flags.length === 0) {\n  if (!unified.orcid) unified.data_quality_flags.push('missing_orcid');\n  if (unified.publications.length === 0 && unified.metrics.publication_count === 0) {\n    unified.data_quality_flags.push('no_publications');\n  }\n  if (unified.affiliations.length === 0) unified.data_quality_flags.push('no_affiliations');\n  if (unified.grants.length === 0) unified.data_quality_flags.push('no_grants');\n  if (!unified.biography) unified.data_quality_flags.push('no_biography');\n}\n\n// ============================================================\n// SECTION 13: Calculate completeness score\n// ============================================================\n\nif (!unified.data_completeness || unified.data_completeness === 0) {\n  let completeness = 0;\n  if (unified.orcid) completeness += 15;\n  if (unified.biography) completeness += 15;\n  if (unified.publications.length > 0 || unified.metrics.publication_count > 0) completeness += 20;\n  if (unified.affiliations.length > 0) completeness += 15;\n  if (unified.metrics.h_index > 0) completeness += 15;\n  if (unified.keywords.length > 0) completeness += 10;\n  if (unified.collaborators.length > 0) completeness += 5;\n  if (unified.research_interests.length > 0) completeness += 5;\n  unified.data_completeness = completeness;\n}\n\n// ============================================================\n// SECTION 14: Return unified object\n// ============================================================\n\nconsole.log(`Pass 1 complete for: ${unified.name}`);\nconsole.log(`  Publications: ${unified.publications.length}, Metrics.pub_count: ${unified.metrics.publication_count}`);\nconsole.log(`  Biography: ${unified.biography ? unified.biography.length + ' chars' : 'NONE'}`);\nconsole.log(`  Research interests: ${unified.research_interests.length}`);\nconsole.log(`  Keywords: ${unified.keywords.length}`);\n\nreturn [{ json: unified }];"
      },
      "id": "c6e8d2de-59cb-4270-bc6b-da2b502e0e40",
      "name": "Pass 1: Unification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2672,
        -16
      ]
    },
    {
      "parameters": {
        "functionCode": "// Pass 3: Build Graph Relationships\n// MODIFIED: Preserves execution_context\n\nconst enrichedObject = $input.first().json;\nconst executionContext = enrichedObject.execution_context;\n\nconst objectId = enrichedObject.object_id;\nconst relationships = [];\n\n// 1. Collaborator relationships\n(enrichedObject.collaborators || []).forEach(collaboratorName => {\n  const slug = collaboratorName.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n  relationships.push({\n    type: 'COLLABORATES_WITH',\n    source: objectId,\n    target: `researcher:${slug}`,\n    properties: {\n      co_author: true,\n      weight: 1\n    }\n  });\n});\n\n// 2. Institutional affiliations\n(enrichedObject.affiliations || []).forEach(affiliation => {\n  const institutionName = affiliation.institution;\n  if (institutionName) {\n    const slug = institutionName.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n    relationships.push({\n      type: 'AFFILIATED_WITH',\n      source: objectId,\n      target: `institution:${slug}`,\n      properties: {\n        role: affiliation.role || affiliation.position || null,\n        department: affiliation.department || null,\n        current: affiliation.current || false,\n        start_date: affiliation.start_date || null,\n        end_date: affiliation.end_date || null\n      }\n    });\n  }\n});\n\n// 3. Research domain connections (from LLM enrichment)\nconst domains = (enrichedObject.enrichment || {}).research_domains || [];\ndomains.forEach(domain => {\n  const slug = domain.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n  relationships.push({\n    type: 'WORKS_IN_DOMAIN',\n    source: objectId,\n    target: `domain:${slug}`,\n    properties: {\n      domain_name: domain\n    }\n  });\n});\n\n// 4. Methodology connections (from LLM enrichment)\nconst methodologies = (enrichedObject.enrichment || {}).methodologies || [];\nmethodologies.forEach(method => {\n  const slug = method.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n  relationships.push({\n    type: 'USES_METHODOLOGY',\n    source: objectId,\n    target: `method:${slug}`,\n    properties: {\n      methodology_name: method\n    }\n  });\n});\n\n// Add graph_relationships to enriched object\nconst withRelationships = {\n  ...enrichedObject,\n  graph_relationships: relationships,\n  execution_context: executionContext  // ADDED: Preserve context\n};\n\nreturn [{ json: withRelationships }];"
      },
      "id": "93453461-4f71-4579-9723-89c28c5cd5ce",
      "name": "Pass 3: Build Relationships",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1120,
        448
      ]
    },
    {
      "parameters": {
        "functionCode": "// Pass 4: Generate ICF Views - Definition Card v3.2 Compliant\n// MODIFIED: Dense view now includes raw_evidence + enriched_context structure\n// MODIFIED: Required for OBJECT-3 classification grounding\n// Creates Dense View, Embedding View, Graph View + provenance\n\nconst enrichedObject = $input.first().json;\nconst executionContext = enrichedObject.execution_context || {};\n\n// Checksum computation function\nfunction computeChecksum(obj) {\n  const str = JSON.stringify(obj);\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return 'sha256:' + Math.abs(hash).toString(16).padStart(16, '0');\n}\n\n// Token estimation (1 token  4 chars for English)\nfunction estimateTokens(text) {\n  return Math.ceil(text.length / 4);\n}\n\n// Transform ID: thin:researcher:colin_barrow  fat:researcher:colin_barrow\nconst thinObjectId = enrichedObject.object_id;\nconst fatObjectId = thinObjectId.replace(/^thin:/, 'fat:');\n\n// ===== NEW: Access nested enrichment structure =====\nconst enrichment = enrichedObject.enrichment || {};\nconst rawEvidence = enrichment.raw_evidence || {};\nconst enrichedContext = enrichment.enriched_context || {};\nconst achievementIndicators = enrichment.achievement_indicators || {};\n\nconst metrics = enrichedObject.metrics || {};\n\n// ====== VERSION HANDLING ======\nconst isRefabrication = executionContext.mode === 'refabrication';\nconst version = executionContext.new_version || 'v1.0';\nconst previousVersion = executionContext.previous_version || null;\nconst refabricationReason = executionContext.refabrication_reason || null;\nconst changedFields = executionContext.changed_fields || [];\nconst sourceQueueEntryId = executionContext.source_queue_entry_id || null;\n\n// ===== NEW: Build raw_evidence for dense_view =====\n// Publications: top 10-15 with abstracts and keywords (CRITICAL for OBJECT-3)\nconst publicationsForDense = (rawEvidence.publications || enrichedObject.publications || [])\n  .slice(0, 15)\n  .map(pub => ({\n    title: pub.title || '',\n    abstract: (pub.abstract || '').substring(0, 500),\n    keywords: pub.keywords || [],\n    year: pub.year || null,\n    citations: pub.citations || 0\n  }));\n\n// Grants: ALL with full details\nconst grantsForDense = (rawEvidence.grants || enrichedObject.grants || [])\n  .map(grant => ({\n    title: grant.title || '',\n    funder: grant.funder || '',\n    amount: grant.amount || null,\n    dates: grant.dates || ''\n  }));\n\n// Biography: complete text (NOT summarised)\nconst biographyForDense = rawEvidence.biography || enrichedObject.biography || '';\n\n// Research interests: original array from source\nconst researchInterestsForDense = rawEvidence.research_interests || enrichedObject.research_interests || [];\n\n// ===== NEW: DENSE VIEW with raw_evidence + enriched_context structure =====\nconst denseView = {\n  object_id: fatObjectId,\n  name: enrichedObject.name,\n  orcid: enrichedObject.orcid || null,\n  institution: enrichedObject.institution || null,\n  \n  // ===== RAW EVIDENCE (CRITICAL FOR OBJECT-3 CLASSIFICATION) =====\n  raw_evidence: {\n    // Top 10-15 publications WITH abstracts and keywords\n    publications: publicationsForDense,\n    \n    // ALL grants with full details\n    grants: grantsForDense,\n    \n    // Complete biography (NOT summarised)\n    biography: biographyForDense,\n    \n    // Original research interests array\n    research_interests: researchInterestsForDense\n  },\n  \n  // ===== ENRICHED CONTEXT (LLM-generated analysis) =====\n  enriched_context: {\n    career_stage: enrichedContext.career_stage || 'unknown',\n    career_stage_evidence: enrichedContext.career_stage_evidence || '',\n    research_domains: enrichedContext.research_domains || [],\n    methodologies: enrichedContext.methodologies || [],\n    themes: enrichedContext.themes || [],\n    keywords: enrichedContext.keywords || []\n  },\n  \n  // ===== ACHIEVEMENT METRICS =====\n  achievement_scale: {\n    h_index: metrics.h_index || 0,\n    total_citations: metrics.total_citations || 0,\n    publication_count: metrics.publication_count || 0,\n    patent_count: metrics.patent_count || 0,\n    grant_count: metrics.grant_count || grantsForDense.length || 0\n  },\n  \n  // Achievement indicators from LLM\n  achievement_indicators: {\n    research_impact: achievementIndicators.research_impact || 'Unknown',\n    collaboration_breadth: achievementIndicators.collaboration_breadth || 'Unknown',\n    funding_track_record: achievementIndicators.funding_track_record || 'Unknown'\n  },\n  \n  // Network\n  collaborator_count: metrics.collaborator_count || 0,\n  \n  // Equipment expertise (if available)\n  equipment_expertise: enrichment.equipment_expertise || [],\n  \n  // Data quality\n  data_completeness: enrichedObject.data_completeness || 0,\n  data_quality_flags: enrichedObject.data_quality_flags || []\n};\n\n// Validate dense view token count (spec: 1200-2000 tokens)\nconst denseTokens = estimateTokens(JSON.stringify(denseView));\nif (denseTokens < 1200) {\n  console.warn(`Dense view tokens (${denseTokens}) below spec minimum 1200`);\n}\nif (denseTokens > 2000) {\n  console.warn(`Dense view tokens (${denseTokens}) above spec maximum 2000`);\n}\n\n// ===== EMBEDDING VIEW (updated to use new structure) =====\nconst embeddingText = `\nResearcher: ${enrichedObject.name}\nInstitution: ${enrichedObject.institution || 'Unknown'}\nCareer Stage: ${enrichedContext.career_stage || 'unknown'}\n\nResearch Domains: ${(enrichedContext.research_domains || []).join(', ')}\n\nCore Methodologies: ${(enrichedContext.methodologies || []).join(', ')}\n\nResearch Themes: ${(enrichedContext.themes || []).join(', ')}\n\nKeywords: ${(enrichedContext.keywords || []).concat(enrichedObject.keywords || []).slice(0, 20).join(', ')}\n\nResearch Interests: ${researchInterestsForDense.join(', ')}\n\nResearch Impact: H-index ${metrics.h_index || 0}, ${metrics.total_citations || 0} citations, ${metrics.publication_count || 0} publications\n\nPatents: ${metrics.patent_count || 0} patents\n\nGrants: ${grantsForDense.length} grants including ${grantsForDense.slice(0, 3).map(g => g.title).join(', ')}\n\nCollaboration: ${achievementIndicators.collaboration_breadth || 'Unknown'} collaboration network with ${metrics.collaborator_count || 0} collaborators\n\nEquipment Expertise: ${(enrichment.equipment_expertise || []).join(', ')}\n`.trim();\n\nconst embeddingTokens = estimateTokens(embeddingText);\nif (embeddingTokens < 300) {\n  console.warn(`Embedding view tokens (${embeddingTokens}) below spec minimum 300`);\n}\nif (embeddingTokens > 800) {\n  console.warn(`Embedding view tokens (${embeddingTokens}) above spec maximum 800`);\n}\n\nconst embeddingView = {\n  text: embeddingText,\n  token_count: embeddingTokens,\n  vector: null  // Will be generated in next node\n};\n\n// === GRAPH VIEW (unchanged) ===\nconst graphView = {\n  relationships: enrichedObject.graph_relationships || []\n};\n\n// === FAT OBJECT (ICF Structure) ===\nconst fatObject = {\n  asset_id: fatObjectId,\n  asset_type: 'object',\n  object_type: 'researcher',\n  version: version,\n  status: 'fabricated',\n  \n  // Three canonical views\n  views: {\n    dense: denseView,\n    embedding: embeddingView,\n    graph: graphView\n  },\n  \n  // Provenance with versioning metadata\n  provenance: {\n    fabricated_from: thinObjectId,\n    fabricated_at: new Date().toISOString(),\n    fabricated_by: isRefabrication ? 'gen2_object_refabrication_v3.2' : 'gen2_object_fabrication_v3.2',\n    enrichment_model: 'gpt-4o-2024-11-20',\n    embedding_model: 'text-embedding-3-large',\n    embedding_dimensions: 768,  // Per Definition Card spec\n    data_sources: enrichedObject.source_metadata?.sources_scraped || ['orcid', 'scopus', 'scholar', 'university', 'patents'],\n    scrape_timestamps: enrichedObject.source_metadata?.scrape_timestamps || {},\n    field_hashes: enrichedObject.source_metadata?.field_hashes || {},\n    checksum: computeChecksum(denseView),\n    \n    // Refabrication metadata\n    is_refabrication: isRefabrication,\n    previous_version: previousVersion,\n    refabrication_reason: refabricationReason,\n    changed_fields: changedFields,\n    source_queue_entry_id: sourceQueueEntryId,\n    \n    // ===== NEW: Token counts for validation =====\n    dense_view_tokens: denseTokens,\n    embedding_view_tokens: embeddingTokens\n  },\n  \n  // Execution context for downstream nodes\n  execution_context: executionContext\n};\n\nreturn [{ json: fatObject }];"
      },
      "id": "cbf4ad9e-fa7a-414e-ac15-757372811232",
      "name": "Pass 4: Generate ICF",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1360,
        448
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "openai/text-embedding-3-large"
            },
            {
              "name": "input",
              "value": "={{ $json.views.embedding.text }}"
            },
            {
              "name": "dimensions",
              "value": "={{ 3072 }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "55c2c13d-27b9-4f86-82e0-3f05f069aca7",
      "name": "Generate Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1600,
        448
      ],
      "credentials": {
        "openRouterApi": {
          "id": "1srwGILgkvMmHRRn",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Merge Embedding\n// MODIFIED: Preserves execution_context\n\n// Get FAT object from Pass 4 via node reference\nconst fatObject = $('Pass 4: Generate ICF').first().json;\nconst executionContext = fatObject.execution_context;\n\n// Get embedding response from Generate Embedding (direct input)\nconst embeddingResponse = $input.first().json;\n\n// Extract the embedding vector\nconst embeddingVector = embeddingResponse.data[0].embedding;\n\n// Add embedding to FAT object\nfatObject.views.embedding.vector = embeddingVector;\nfatObject.views.embedding.model = 'text-embedding-3-large';\nfatObject.views.embedding.dimensions = 3072;\n\n// Preserve execution context\nfatObject.execution_context = executionContext;\n\nreturn [{ json: fatObject }];"
      },
      "id": "4171a452-b06d-45e0-a749-4239dada829e",
      "name": "Merge Embedding",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1840,
        448
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Store Neo4j - Full version with APOC relationship creation\n// UPDATED: Idempotent storage for both normal and refabrication modes\n\nconst fatObject = $input.first().json;\nconst executionContext = fatObject.execution_context || {};\nconst isRefabrication = executionContext.mode === 'refabrication';\n\nlet statement;\nlet parameters;\n\nif (isRefabrication) {\n  // REFABRICATION MODE: MERGE on asset_id + version (idempotent - safe for retries)\n  statement = `\n    // Step 1: Create or update FATObject version (idempotent)\n    MERGE (fat:FATObject {asset_id: $asset_id, version: $version})\n    SET fat.name = $name,\n        fat.orcid = $orcid,\n        fat.institution = $institution,\n        fat.status = 'fabricated',\n        fat.fabricated_at = timestamp(),\n        fat.dense_view = $dense_view,\n        fat.data_completeness = $data_completeness,\n        fat.previous_version = $previous_version,\n        fat.refabrication_reason = $refabrication_reason,\n        fat.source_queue_entry_id = $source_queue_entry_id\n    \n    // Step 2: Link to ThinObject and update its status\n    WITH fat\n    MATCH (thin:ThinObject {asset_id: $thin_object_id})\n    MERGE (fat)-[:FABRICATED_FROM]->(thin)\n    SET thin.status = 'refabricated',\n        thin.refabricated_at = timestamp(),\n        thin.latest_version = $version\n    \n    // Step 3: Create relationships to other entities (idempotent)\n    WITH fat\n    UNWIND $relationships AS rel\n    WITH fat, rel, split(rel.target, ':') AS parts\n    WITH fat, rel, parts[0] AS targetLabel, rel.target AS targetId\n    \n    // Create or merge target node dynamically\n    CALL apoc.merge.node([targetLabel], {id: targetId}) YIELD node AS targetNode\n    \n    // Create or merge relationship dynamically (idempotent)\n    CALL apoc.merge.relationship(fat, rel.type, {}, rel.properties, targetNode) YIELD rel AS mergedRel\n    \n    RETURN count(mergedRel) AS relationships_created, fat.asset_id AS created_asset_id, fat.version AS created_version\n  `;\n  \n  parameters = {\n    asset_id: fatObject.asset_id,\n    version: fatObject.version,\n    thin_object_id: fatObject.provenance.fabricated_from,\n    name: fatObject.views.dense.name,\n    orcid: fatObject.views.dense.orcid || null,\n    institution: fatObject.views.dense.institution || null,\n    dense_view: JSON.stringify(fatObject.views.dense),\n    data_completeness: fatObject.views.dense.data_completeness,\n    previous_version: fatObject.provenance.previous_version,\n    refabrication_reason: fatObject.provenance.refabrication_reason,\n    source_queue_entry_id: fatObject.provenance.source_queue_entry_id,\n    relationships: fatObject.views.graph.relationships\n  };\n} else {\n  // NORMAL MODE: Merge on asset_id (original behavior)\n  statement = `\n    // Step 1: Create or update FATObject node\n    MERGE (fat:FATObject {asset_id: $asset_id})\n    SET fat.name = $name,\n        fat.orcid = $orcid,\n        fat.institution = $institution,\n        fat.status = 'fabricated',\n        fat.fabricated_at = timestamp(),\n        fat.dense_view = $dense_view,\n        fat.data_completeness = $data_completeness,\n        fat.version = $version\n    \n    // Step 2: Link to ThinObject and update its status\n    WITH fat\n    MATCH (thin:ThinObject {asset_id: $thin_object_id})\n    MERGE (fat)-[:FABRICATED_FROM]->(thin)\n    SET thin.status = 'fabricated',\n        thin.fabricated_at = timestamp()\n    \n    // Step 3: Create relationships to other entities\n    WITH fat\n    UNWIND $relationships AS rel\n    WITH fat, rel, split(rel.target, ':') AS parts\n    WITH fat, rel, parts[0] AS targetLabel, rel.target AS targetId\n    \n    // Create or merge target node dynamically\n    CALL apoc.merge.node([targetLabel], {id: targetId}) YIELD node AS targetNode\n    \n    // Create relationship dynamically\n    CALL apoc.create.relationship(fat, rel.type, rel.properties, targetNode) YIELD rel AS createdRel\n    \n    RETURN count(createdRel) AS relationships_created\n  `;\n  \n  parameters = {\n    asset_id: fatObject.asset_id,\n    thin_object_id: fatObject.provenance.fabricated_from,\n    name: fatObject.views.dense.name,\n    orcid: fatObject.views.dense.orcid || null,\n    institution: fatObject.views.dense.institution || null,\n    dense_view: JSON.stringify(fatObject.views.dense),\n    data_completeness: fatObject.views.dense.data_completeness,\n    version: fatObject.version,\n    relationships: fatObject.views.graph.relationships\n  };\n}\n\nreturn [{\n  json: {\n    neo4j_payload: {\n      statement: statement,\n      parameters: parameters\n    },\n    fat_object: fatObject,\n    execution_context: executionContext\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2080,
        448
      ],
      "id": "438971de-9df0-423f-ad1b-2cc6cdf637a0",
      "name": "Prepare Store Neo4j"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://8b9cbf46.databases.neo4j.io/db/neo4j/query/v2",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.neo4j_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        304,
        848
      ],
      "id": "0a37e2a9-cbfd-4c9e-ac46-cc19f5638b6a",
      "name": "Store in Neo4j",
      "credentials": {
        "httpBasicAuth": {
          "id": "HximmqteOLptnTyu",
          "name": "Neo4j Gen 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare Qdrant Payload for FATObject storage\n// MODIFIED: Includes version in payload for refabrication support\n\nconst fatObject = $('Merge Embedding').first().json;\nconst executionContext = fatObject.execution_context || {};\n\n// Generate deterministic UUID from asset_id + version\nfunction stringToUUID(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  \n  const hex = Math.abs(hash).toString(16).padStart(8, '0');\n  const len = str.length.toString(16).padStart(4, '0');\n  \n  let hash2 = 0;\n  for (let i = str.length - 1; i >= 0; i--) {\n    hash2 = ((hash2 << 3) + hash2) + str.charCodeAt(i);\n  }\n  const hex2 = Math.abs(hash2).toString(16).padStart(12, '0');\n  \n  return `${hex}-${len}-4000-8000-${hex2}`.substring(0, 36);\n}\n\n// For refabrication, include version in UUID generation to create unique point\nconst isRefabrication = executionContext.mode === 'refabrication';\nconst pointIdSource = isRefabrication \n  ? `${fatObject.asset_id}:${fatObject.version}` \n  : fatObject.asset_id;\nconst pointId = stringToUUID(pointIdSource);\n\n// Build the Qdrant point\nconst qdrantPayload = {\n  id: pointId,\n  vector: fatObject.views.embedding.vector,\n  payload: {\n    asset_id: fatObject.asset_id,\n    version: fatObject.version,  // ADDED: Version tracking\n    object_type: \"researcher\",\n    name: fatObject.views.dense.name,\n    institution: fatObject.views.dense.institution || null,\n    orcid: fatObject.views.dense.orcid || null,\n    research_domains: fatObject.views.dense.research_domains,\n    methodologies: fatObject.views.dense.core_methodologies,\n    research_themes: fatObject.views.dense.research_themes,\n    h_index: fatObject.views.dense.h_index,\n    total_citations: fatObject.views.dense.total_citations,\n    publication_count: fatObject.views.dense.publication_count,\n    patent_count: fatObject.views.dense.patent_count,\n    career_stage: fatObject.views.dense.career_stage,\n    research_impact: fatObject.views.dense.research_impact,\n    data_completeness: fatObject.views.dense.data_completeness,\n    status: \"fabricated\",\n    fabricated_at: fatObject.provenance.fabricated_at,\n    // ADDED: Refabrication metadata\n    is_refabrication: isRefabrication,\n    previous_version: fatObject.provenance.previous_version || null\n  }\n};\n\nreturn [{\n  json: {\n    qdrant_payloads: [qdrantPayload],\n    execution_context: executionContext\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        848
      ],
      "id": "122c35a1-5334-4c87-8aba-9dbfe566f4b8",
      "name": "Prepare Qdrant Payload"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "https://3d3d355d-350c-4fd3-a844-17ca2599c7c0.europe-west3-0.gcp.cloud.qdrant.io/collections/objects_researchers_v1/points?wait=true",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "qdrantRestApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{\n     {\n       \"points\": $json.qdrant_payloads\n     }\n   }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        784,
        848
      ],
      "id": "288f9fbd-d3ad-40d2-a75b-3bc35e0886b1",
      "name": "Store in Qdrant",
      "credentials": {
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare PostgreSQL Audit Log\n// MODIFIED: Includes refabrication metadata\n// FIXED: data_completeness converted to integer percentage\n\nconst fatObject = $('Merge Embedding').first().json;\nconst executionContext = fatObject.execution_context || {};\nconst isRefabrication = executionContext.mode === 'refabrication';\n\n// FIX: Convert data_completeness to integer (handle both ratio and percentage)\nconst rawCompleteness = fatObject.views.dense.data_completeness;\nconst dataCompleteness = rawCompleteness <= 1 \n  ? Math.round(rawCompleteness * 100)  // Convert 0.8  80\n  : Math.round(rawCompleteness);        // Keep 80  80\n\nconst supabasePayload = [{\n  asset_id: fatObject.asset_id,\n  status: 'fabricated',\n  checksum: fatObject.provenance.checksum,\n  version: fatObject.version,\n  job_id: $execution?.id || null,\n  enriched_by: fatObject.provenance.fabricated_by,\n  object_type: 'researcher',\n  data_completeness: dataCompleteness,  // FIXED: Now integer\n  enrichment_model: fatObject.provenance.enrichment_model,\n  embedding_model: fatObject.provenance.embedding_model,\n  fabricated_at: fatObject.provenance.fabricated_at,\n  // ADDED: Refabrication metadata\n  is_refabrication: isRefabrication,\n  previous_version: fatObject.provenance.previous_version || null,\n  refabrication_reason: fatObject.provenance.refabrication_reason || null,\n  source_queue_entry_id: fatObject.provenance.source_queue_entry_id || null\n}];\n\nreturn [{\n  json: {\n    supabase_payload: supabasePayload,\n    total_records: supabasePayload.length,\n    execution_context: executionContext\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        848
      ],
      "id": "c7147eb2-475d-4969-864c-7fbc5887d49e",
      "name": "Prepare PostgreSQL Payload"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://esgwrqcyhtzcsbepvqhc.supabase.co/rest/v1/fabrication_audit?on_conflict=asset_id,version",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates, return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.supabase_payload }}",
        "options": {
          "timeout": 30000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1264,
        848
      ],
      "id": "51b29f08-dbcf-4751-9ce3-cdf83722e714",
      "name": "Store in Supabase(Postgre)",
      "credentials": {
        "qdrantRestApi": {
          "id": "5kvIJD32UkQxRAis",
          "name": "Qdrant account"
        },
        "supabaseApi": {
          "id": "vTKATqGswB3PHE6S",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Node: Prepare Fetch ThinObjects\n// Fetches Colin Barrow ThinObject for testing\nconst batchSize = 1;\nreturn [{\n  json: {\n    neo4j_payload: {\n      statement: `\n        MATCH (thin:ThinObject)\n        WHERE thin.status = $status\n          AND thin.object_type = $object_type\n          AND toLower(thin.name) CONTAINS 'barrow'\n          AND NOT EXISTS((thin)<-[:FABRICATED_FROM]-(:FATObject))\n        RETURN {\n          object_id: thin.asset_id,\n          name: thin.name,\n          orcid: thin.orcid,\n          email: thin.email,\n          institution: thin.institution,\n          orcid_data: thin.orcid_data,\n          scopus_data: thin.scopus_data,\n          scholar_data: thin.scholar_data,\n          university_data: thin.university_data,\n          patents_data: thin.patents_data,\n          source_metadata: thin.source_metadata,\n          created_at: thin.created_at\n        } as thin_object\n        ORDER BY thin.created_at ASC\n        LIMIT $limit\n      `,\n      parameters: {\n        status: \"raw\",\n        object_type: \"researcher\",\n        limit: batchSize\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        -640
      ],
      "id": "8b8bc18e-a90b-49a7-86b2-b1d0d7831462",
      "name": "Prepare Fetch ThinObjects (colin)"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Fetch ThinObjects - Normal Mode\n// Fetches raw ThinObjects ready for initial fabrication\n// UPDATED: Now fetches direct fields stored by OBJECT-1 v3.x\n\nconst executionContext = $input.first().json;\nconst batchSize = 5;\n\nreturn [{\n  json: {\n    execution_context: executionContext,\n    neo4j_payload: {\n      statement: `\n        MATCH (thin:ThinObject)\n        WHERE thin.status = $status\n          AND thin.object_type = $object_type\n          AND NOT EXISTS((thin)<-[:FABRICATED_FROM]-(:FATObject))\n        RETURN {\n          object_id: thin.asset_id,\n          name: thin.name,\n          orcid: thin.orcid,\n          email: thin.email,\n          institution: thin.institution,\n          \n          // NEW: Direct fields from OBJECT-1 v3.x\n          biography: thin.biography,\n          research_interests: thin.research_interests,\n          current_projects: thin.current_projects,\n          expertise_keywords: thin.expertise_keywords,\n          collaborators: thin.collaborators,\n          keywords: thin.keywords,\n          publications: thin.publications,\n          patents: thin.patents,\n          affiliations: thin.affiliations,\n          grants: thin.grants,\n          metrics: thin.metrics,\n          data_quality_flags: thin.data_quality_flags,\n          data_completeness: thin.data_completeness,\n          field_hashes: thin.field_hashes,\n          \n          // Legacy JSON fields (backward compatibility)\n          orcid_data: thin.orcid_data,\n          scopus_data: thin.scopus_data,\n          scholar_data: thin.scholar_data,\n          university_data: thin.university_data,\n          patents_data: thin.patents_data,\n          source_metadata: thin.source_metadata,\n          created_at: thin.created_at\n        } as thin_object\n        ORDER BY thin.created_at ASC\n        LIMIT $limit\n      `,\n      parameters: {\n        status: \"raw\",\n        object_type: \"researcher\",\n        limit: batchSize\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1184,
        -32
      ],
      "id": "a2a28673-cdcf-4335-93ac-20f5e3e6c6d5",
      "name": "Prepare Fetch ThinObjects"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "messages": {
          "messageValues": [
            {
              "message": "You are a research profile enrichment specialist. Always respond with valid JSON only."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        592,
        448
      ],
      "id": "effd54ed-af5d-4375-978a-f23c8a6eeed2",
      "name": "Pass 2: LLM Enrichment"
    }
  ],
  "pinData": {
    "Schedule Trigger": [
      {
        "json": {
          "timestamp": "2025-12-24T08:30:32.003+11:00",
          "Readable date": "December 24th 2025, 8:30:32 am",
          "Readable time": "8:30:32 am",
          "Day of week": "Wednesday",
          "Year": "2025",
          "Month": "December",
          "Day of month": "24",
          "Hour": "08",
          "Minute": "30",
          "Second": "32",
          "Timezone": "Australia/Melbourne (UTC+11:00)"
        }
      }
    ],
    "Schedule Trigger1": [
      {
        "json": {
          "timestamp": "2025-12-24T08:30:07.676+11:00",
          "Readable date": "December 24th 2025, 8:30:07 am",
          "Readable time": "8:30:07 am",
          "Day of week": "Wednesday",
          "Year": "2025",
          "Month": "December",
          "Day of month": "24",
          "Hour": "08",
          "Minute": "30",
          "Second": "07",
          "Timezone": "Australia/Melbourne (UTC+11:00)"
        }
      }
    ]
  },
  "connections": {
    "Schedule Trigger": {
      "main": [
        []
      ]
    },
    "Webhook Trigger (Refab)": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Inputs": {
      "main": [
        [
          {
            "node": "Route by Mode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Mode": {
      "main": [
        [
          {
            "node": "Prepare Fetch ThinObjects",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Fetch ThinObject (Refab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Fetch ThinObject (Refab)": {
      "main": [
        [
          {
            "node": "Fetch ThinObject (Refab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch ThinObject (Refab)": {
      "main": [
        [
          {
            "node": "Prepare Set Status (Refab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Set Status (Refab)": {
      "main": [
        [
          {
            "node": "Set Status: Refabricating",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Status: Refabricating": {
      "main": [
        [
          {
            "node": "Split ThinObjects (Refab)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split ThinObjects": {
      "main": [
        [
          {
            "node": "Loop Through Objects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split ThinObjects (Refab)": {
      "main": [
        [
          {
            "node": "Loop Through Objects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Mode for Response": {
      "main": [
        [
          {
            "node": "Route Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Completion": {
      "main": [
        [
          {
            "node": "Respond to Webhook (Refab)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Back (Normal)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Back (Normal)": {
      "main": [
        [
          {
            "node": "Loop Through Objects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger1": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Pass 2: LLM Enrichment",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Prepare LLM Prompt": {
      "main": [
        [
          {
            "node": "Pass 2: LLM Enrichment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          {
            "node": "Pass 3: Build Relationships",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch ThinObjects": {
      "main": [
        [
          {
            "node": "Prepare Set Status Fabricating",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Set Status Fabricating": {
      "main": [
        [
          {
            "node": "Set Status: Fabricating",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Status: Fabricating": {
      "main": [
        [
          {
            "node": "Split ThinObjects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Through Objects": {
      "main": [
        [],
        [
          {
            "node": "Pass 1: Unification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass 1: Unification": {
      "main": [
        [
          {
            "node": "Prepare LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass 3: Build Relationships": {
      "main": [
        [
          {
            "node": "Pass 4: Generate ICF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass 4: Generate ICF": {
      "main": [
        [
          {
            "node": "Generate Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding": {
      "main": [
        [
          {
            "node": "Merge Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Embedding": {
      "main": [
        [
          {
            "node": "Prepare Store Neo4j",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Store Neo4j": {
      "main": [
        [
          {
            "node": "Store in Neo4j",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Neo4j": {
      "main": [
        [
          {
            "node": "Prepare Qdrant Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Qdrant Payload": {
      "main": [
        [
          {
            "node": "Store in Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Qdrant": {
      "main": [
        [
          {
            "node": "Prepare PostgreSQL Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare PostgreSQL Payload": {
      "main": [
        [
          {
            "node": "Store in Supabase(Postgre)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Supabase(Postgre)": {
      "main": [
        [
          {
            "node": "Check Mode for Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Fetch ThinObjects (colin)": {
      "main": [
        []
      ]
    },
    "Prepare Fetch ThinObjects": {
      "main": [
        [
          {
            "node": "Fetch ThinObjects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass 2: LLM Enrichment": {
      "main": [
        [
          {
            "node": "Parse LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "0d27de81-7e0e-4058-952f-b705aff30618",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bc0e623ae1bb3524870487de3c7fa60f3a571019006cc26dd79ca981250a48aa"
  },
  "id": "teZrSkEFhH8Ig7Ii",
  "tags": [
    {
      "updatedAt": "2025-12-18T21:22:51.435Z",
      "createdAt": "2025-11-25T14:19:55.471Z",
      "id": "23TAoanPtB83dwz5",
      "name": "Fabrication"
    },
    {
      "updatedAt": "2025-11-19T16:16:22.409Z",
      "createdAt": "2025-11-19T16:16:22.409Z",
      "id": "M2HE4sAVj28MumnE",
      "name": "Gen 2"
    },
    {
      "updatedAt": "2025-12-21T18:50:50.363Z",
      "createdAt": "2025-12-21T18:50:50.363Z",
      "id": "bMUumpA7DKh30mJG",
      "name": "GEN 5"
    },
    {
      "updatedAt": "2025-11-25T14:19:55.412Z",
      "createdAt": "2025-11-25T14:19:55.412Z",
      "id": "eBZKHdMEtFCUtF7o",
      "name": "researchers"
    }
  ]
}